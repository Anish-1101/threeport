// generated by 'threeport-codegen api-model' - do not edit

package v0

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	v0 "github.com/threeport/threeport/pkg/api/v0"
	client "github.com/threeport/threeport/pkg/client"
	"net/http"
)

// GetLogBackendByID feteches a log backend by ID
func GetLogBackendByID(id uint, apiAddr, apiToken string) (*v0.LogBackend, error) {
	var logBackend v0.LogBackend

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/log_backends/%d", apiAddr, ApiVersion, id),
		apiToken,
		http.MethodGet,
		new(bytes.Buffer),
		http.StatusOK,
	)
	if err != nil {
		return &logBackend, err
	}

	jsonData, err := json.Marshal(response.Data[0])
	if err != nil {
		return &logBackend, err
	}

	if err = json.Unmarshal(jsonData, &logBackend); err != nil {
		return &logBackend, err
	}

	return &logBackend, nil
}

// GetLogBackendByName feteches a log backend by name
func GetLogBackendByName(name, apiAddr, apiToken string) (*v0.LogBackend, error) {
	var logBackends []v0.LogBackend

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/log_backends?name=%s", apiAddr, ApiVersion, name),
		apiToken,
		http.MethodGet,
		new(bytes.Buffer),
		http.StatusOK,
	)
	if err != nil {
		return &v0.LogBackend{}, err
	}

	jsonData, err := json.Marshal(response.Data)
	if err != nil {
		return &v0.LogBackend{}, err
	}

	if err = json.Unmarshal(jsonData, &logBackends); err != nil {
		return &v0.LogBackend{}, err
	}

	switch {
	case len(logBackends) < 1:
		return &v0.LogBackend{}, errors.New(fmt.Sprintf("no workload definitions with name %s", name))
	case len(logBackends) > 1:
		return &v0.LogBackend{}, errors.New(fmt.Sprintf("more than one workload definition with name %s returned", name))
	}

	return &logBackends[0], nil
}

// CreateLogBackend creates a new log backend
func CreateLogBackend(logBackend *v0.LogBackend, apiAddr, apiToken string) (*v0.LogBackend, error) {
	jsonLogBackend, err := client.MarshalObject(logBackend)
	if err != nil {
		return logBackend, err
	}

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/log_backends", apiAddr, ApiVersion),
		apiToken,
		http.MethodGet,
		bytes.NewBuffer(jsonLogBackend),
		http.StatusCreated,
	)
	if err != nil {
		return logBackend, err
	}

	jsonData, err := json.Marshal(response.Data[0])
	if err != nil {
		return logBackend, err
	}

	if err = json.Unmarshal(jsonData, &logBackend); err != nil {
		return logBackend, err
	}

	return logBackend, nil
}

// UpdateLogBackend updates a log backend
func UpdateLogBackend(logBackend *v0.LogBackend, apiAddr, apiToken string) (*v0.LogBackend, error) {
	jsonLogBackend, err := client.MarshalObject(logBackend)
	if err != nil {
		return logBackend, err
	}

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/log_backends/%d", apiAddr, ApiVersion, *logBackend.ID),
		apiToken,
		http.MethodPatch,
		bytes.NewBuffer(jsonLogBackend),
		http.StatusOK,
	)
	if err != nil {
		return logBackend, err
	}

	jsonData, err := json.Marshal(response.Data[0])
	if err != nil {
		return logBackend, err
	}

	if err = json.Unmarshal(jsonData, &logBackend); err != nil {
		return logBackend, err
	}

	return logBackend, nil
}

// GetLogStorageDefinitionByID feteches a log storage definition by ID
func GetLogStorageDefinitionByID(id uint, apiAddr, apiToken string) (*v0.LogStorageDefinition, error) {
	var logStorageDefinition v0.LogStorageDefinition

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/log_storage_definitions/%d", apiAddr, ApiVersion, id),
		apiToken,
		http.MethodGet,
		new(bytes.Buffer),
		http.StatusOK,
	)
	if err != nil {
		return &logStorageDefinition, err
	}

	jsonData, err := json.Marshal(response.Data[0])
	if err != nil {
		return &logStorageDefinition, err
	}

	if err = json.Unmarshal(jsonData, &logStorageDefinition); err != nil {
		return &logStorageDefinition, err
	}

	return &logStorageDefinition, nil
}

// GetLogStorageDefinitionByName feteches a log storage definition by name
func GetLogStorageDefinitionByName(name, apiAddr, apiToken string) (*v0.LogStorageDefinition, error) {
	var logStorageDefinitions []v0.LogStorageDefinition

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/log_storage_definitions?name=%s", apiAddr, ApiVersion, name),
		apiToken,
		http.MethodGet,
		new(bytes.Buffer),
		http.StatusOK,
	)
	if err != nil {
		return &v0.LogStorageDefinition{}, err
	}

	jsonData, err := json.Marshal(response.Data)
	if err != nil {
		return &v0.LogStorageDefinition{}, err
	}

	if err = json.Unmarshal(jsonData, &logStorageDefinitions); err != nil {
		return &v0.LogStorageDefinition{}, err
	}

	switch {
	case len(logStorageDefinitions) < 1:
		return &v0.LogStorageDefinition{}, errors.New(fmt.Sprintf("no workload definitions with name %s", name))
	case len(logStorageDefinitions) > 1:
		return &v0.LogStorageDefinition{}, errors.New(fmt.Sprintf("more than one workload definition with name %s returned", name))
	}

	return &logStorageDefinitions[0], nil
}

// CreateLogStorageDefinition creates a new log storage definition
func CreateLogStorageDefinition(logStorageDefinition *v0.LogStorageDefinition, apiAddr, apiToken string) (*v0.LogStorageDefinition, error) {
	jsonLogStorageDefinition, err := client.MarshalObject(logStorageDefinition)
	if err != nil {
		return logStorageDefinition, err
	}

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/log_storage_definitions", apiAddr, ApiVersion),
		apiToken,
		http.MethodGet,
		bytes.NewBuffer(jsonLogStorageDefinition),
		http.StatusCreated,
	)
	if err != nil {
		return logStorageDefinition, err
	}

	jsonData, err := json.Marshal(response.Data[0])
	if err != nil {
		return logStorageDefinition, err
	}

	if err = json.Unmarshal(jsonData, &logStorageDefinition); err != nil {
		return logStorageDefinition, err
	}

	return logStorageDefinition, nil
}

// UpdateLogStorageDefinition updates a log storage definition
func UpdateLogStorageDefinition(logStorageDefinition *v0.LogStorageDefinition, apiAddr, apiToken string) (*v0.LogStorageDefinition, error) {
	jsonLogStorageDefinition, err := client.MarshalObject(logStorageDefinition)
	if err != nil {
		return logStorageDefinition, err
	}

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/log_storage_definitions/%d", apiAddr, ApiVersion, *logStorageDefinition.ID),
		apiToken,
		http.MethodPatch,
		bytes.NewBuffer(jsonLogStorageDefinition),
		http.StatusOK,
	)
	if err != nil {
		return logStorageDefinition, err
	}

	jsonData, err := json.Marshal(response.Data[0])
	if err != nil {
		return logStorageDefinition, err
	}

	if err = json.Unmarshal(jsonData, &logStorageDefinition); err != nil {
		return logStorageDefinition, err
	}

	return logStorageDefinition, nil
}

// GetLogStorageInstanceByID feteches a log storage instance by ID
func GetLogStorageInstanceByID(id uint, apiAddr, apiToken string) (*v0.LogStorageInstance, error) {
	var logStorageInstance v0.LogStorageInstance

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/log_storage_instances/%d", apiAddr, ApiVersion, id),
		apiToken,
		http.MethodGet,
		new(bytes.Buffer),
		http.StatusOK,
	)
	if err != nil {
		return &logStorageInstance, err
	}

	jsonData, err := json.Marshal(response.Data[0])
	if err != nil {
		return &logStorageInstance, err
	}

	if err = json.Unmarshal(jsonData, &logStorageInstance); err != nil {
		return &logStorageInstance, err
	}

	return &logStorageInstance, nil
}

// GetLogStorageInstanceByName feteches a log storage instance by name
func GetLogStorageInstanceByName(name, apiAddr, apiToken string) (*v0.LogStorageInstance, error) {
	var logStorageInstances []v0.LogStorageInstance

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/log_storage_instances?name=%s", apiAddr, ApiVersion, name),
		apiToken,
		http.MethodGet,
		new(bytes.Buffer),
		http.StatusOK,
	)
	if err != nil {
		return &v0.LogStorageInstance{}, err
	}

	jsonData, err := json.Marshal(response.Data)
	if err != nil {
		return &v0.LogStorageInstance{}, err
	}

	if err = json.Unmarshal(jsonData, &logStorageInstances); err != nil {
		return &v0.LogStorageInstance{}, err
	}

	switch {
	case len(logStorageInstances) < 1:
		return &v0.LogStorageInstance{}, errors.New(fmt.Sprintf("no workload definitions with name %s", name))
	case len(logStorageInstances) > 1:
		return &v0.LogStorageInstance{}, errors.New(fmt.Sprintf("more than one workload definition with name %s returned", name))
	}

	return &logStorageInstances[0], nil
}

// CreateLogStorageInstance creates a new log storage instance
func CreateLogStorageInstance(logStorageInstance *v0.LogStorageInstance, apiAddr, apiToken string) (*v0.LogStorageInstance, error) {
	jsonLogStorageInstance, err := client.MarshalObject(logStorageInstance)
	if err != nil {
		return logStorageInstance, err
	}

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/log_storage_instances", apiAddr, ApiVersion),
		apiToken,
		http.MethodGet,
		bytes.NewBuffer(jsonLogStorageInstance),
		http.StatusCreated,
	)
	if err != nil {
		return logStorageInstance, err
	}

	jsonData, err := json.Marshal(response.Data[0])
	if err != nil {
		return logStorageInstance, err
	}

	if err = json.Unmarshal(jsonData, &logStorageInstance); err != nil {
		return logStorageInstance, err
	}

	return logStorageInstance, nil
}

// UpdateLogStorageInstance updates a log storage instance
func UpdateLogStorageInstance(logStorageInstance *v0.LogStorageInstance, apiAddr, apiToken string) (*v0.LogStorageInstance, error) {
	jsonLogStorageInstance, err := client.MarshalObject(logStorageInstance)
	if err != nil {
		return logStorageInstance, err
	}

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/log_storage_instances/%d", apiAddr, ApiVersion, *logStorageInstance.ID),
		apiToken,
		http.MethodPatch,
		bytes.NewBuffer(jsonLogStorageInstance),
		http.StatusOK,
	)
	if err != nil {
		return logStorageInstance, err
	}

	jsonData, err := json.Marshal(response.Data[0])
	if err != nil {
		return logStorageInstance, err
	}

	if err = json.Unmarshal(jsonData, &logStorageInstance); err != nil {
		return logStorageInstance, err
	}

	return logStorageInstance, nil
}
