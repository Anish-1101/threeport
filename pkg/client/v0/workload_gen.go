// generated by 'threeport-codegen api-model' - do not edit

package v0

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	v0 "github.com/threeport/threeport/pkg/api/v0"
	"net/http"
)

// GetWorkloadDefinitionByID feteches a workload definition by ID
func GetWorkloadDefinitionByID(id uint, apiAddr, apiToken string) (*v0.WorkloadDefinition, error) {
	var workloadDefinition v0.WorkloadDefinition

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/workload_definitions/%d", apiAddr, ApiVersion, id),
		apiToken,
		http.MethodGet,
		new(bytes.Buffer),
		http.StatusOK,
	)
	if err != nil {
		return &workloadDefinition, err
	}

	jsonData, err := json.Marshal(response.Data[0])
	if err != nil {
		return &workloadDefinition, err
	}

	if err = json.Unmarshal(jsonData, &workloadDefinition); err != nil {
		return &workloadDefinition, err
	}

	return &workloadDefinition, nil
}

// GetWorkloadDefinitionByName feteches a workload definition by name
func GetWorkloadDefinitionByName(name, apiAddr, apiToken string) (*v0.WorkloadDefinition, error) {
	var workloadDefinitions []v0.WorkloadDefinition

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/workload_definitions?name=%s", apiAddr, ApiVersion, name),
		apiToken,
		http.MethodGet,
		new(bytes.Buffer),
		http.StatusOK,
	)
	if err != nil {
		return &v0.WorkloadDefinition{}, err
	}

	jsonData, err := json.Marshal(response.Data)
	if err != nil {
		return &v0.WorkloadDefinition{}, err
	}

	if err = json.Unmarshal(jsonData, &workloadDefinitions); err != nil {
		return &v0.WorkloadDefinition{}, err
	}

	switch {
	case len(workloadDefinitions) < 1:
		return &v0.WorkloadDefinition{}, errors.New(fmt.Sprintf("no workload definitions with name %s", name))
	case len(workloadDefinitions) > 1:
		return &v0.WorkloadDefinition{}, errors.New(fmt.Sprintf("more than one workload definition with name %s returned", name))
	}

	return &workloadDefinitions[0], nil
}

// CreateWorkloadDefinition creates a new workload definition
func CreateWorkloadDefinition(jsonWorkloadDefinition []byte, apiAddr, apiToken string) (*v0.WorkloadDefinition, error) {
	var workloadDefinition v0.WorkloadDefinition

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/workload_definitions", apiAddr, ApiVersion),
		apiToken,
		http.MethodGet,
		bytes.NewBuffer(jsonWorkloadDefinition),
		http.StatusCreated,
	)
	if err != nil {
		return &workloadDefinition, err
	}

	jsonData, err := json.Marshal(response.Data[0])
	if err != nil {
		return &workloadDefinition, err
	}

	if err = json.Unmarshal(jsonData, &workloadDefinition); err != nil {
		return &workloadDefinition, err
	}

	return &workloadDefinition, nil
}

// UpdateWorkloadDefinition creates a new workload definition
func UpdateWorkloadDefinition(id uint, jsonWorkloadDefinition []byte, apiAddr, apiToken string) (*v0.WorkloadDefinition, error) {
	var workloadDefinition v0.WorkloadDefinition

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/workload_definitions/%d", apiAddr, ApiVersion, id),
		apiToken,
		http.MethodPatch,
		bytes.NewBuffer(jsonWorkloadDefinition),
		http.StatusOK,
	)
	if err != nil {
		return &workloadDefinition, err
	}

	jsonData, err := json.Marshal(response.Data[0])
	if err != nil {
		return &workloadDefinition, err
	}

	if err = json.Unmarshal(jsonData, &workloadDefinition); err != nil {
		return &workloadDefinition, err
	}

	return &workloadDefinition, nil
}

// GetWorkloadResourceDefinitionByID feteches a workload resource definition by ID
func GetWorkloadResourceDefinitionByID(id uint, apiAddr, apiToken string) (*v0.WorkloadResourceDefinition, error) {
	var workloadResourceDefinition v0.WorkloadResourceDefinition

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/workload_resource_definitions/%d", apiAddr, ApiVersion, id),
		apiToken,
		http.MethodGet,
		new(bytes.Buffer),
		http.StatusOK,
	)
	if err != nil {
		return &workloadResourceDefinition, err
	}

	jsonData, err := json.Marshal(response.Data[0])
	if err != nil {
		return &workloadResourceDefinition, err
	}

	if err = json.Unmarshal(jsonData, &workloadResourceDefinition); err != nil {
		return &workloadResourceDefinition, err
	}

	return &workloadResourceDefinition, nil
}

// GetWorkloadResourceDefinitionByName feteches a workload resource definition by name
func GetWorkloadResourceDefinitionByName(name, apiAddr, apiToken string) (*v0.WorkloadResourceDefinition, error) {
	var workloadResourceDefinitions []v0.WorkloadResourceDefinition

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/workload_resource_definitions?name=%s", apiAddr, ApiVersion, name),
		apiToken,
		http.MethodGet,
		new(bytes.Buffer),
		http.StatusOK,
	)
	if err != nil {
		return &v0.WorkloadResourceDefinition{}, err
	}

	jsonData, err := json.Marshal(response.Data)
	if err != nil {
		return &v0.WorkloadResourceDefinition{}, err
	}

	if err = json.Unmarshal(jsonData, &workloadResourceDefinitions); err != nil {
		return &v0.WorkloadResourceDefinition{}, err
	}

	switch {
	case len(workloadResourceDefinitions) < 1:
		return &v0.WorkloadResourceDefinition{}, errors.New(fmt.Sprintf("no workload definitions with name %s", name))
	case len(workloadResourceDefinitions) > 1:
		return &v0.WorkloadResourceDefinition{}, errors.New(fmt.Sprintf("more than one workload definition with name %s returned", name))
	}

	return &workloadResourceDefinitions[0], nil
}

// CreateWorkloadResourceDefinition creates a new workload resource definition
func CreateWorkloadResourceDefinition(jsonWorkloadResourceDefinition []byte, apiAddr, apiToken string) (*v0.WorkloadResourceDefinition, error) {
	var workloadResourceDefinition v0.WorkloadResourceDefinition

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/workload_resource_definitions", apiAddr, ApiVersion),
		apiToken,
		http.MethodGet,
		bytes.NewBuffer(jsonWorkloadResourceDefinition),
		http.StatusCreated,
	)
	if err != nil {
		return &workloadResourceDefinition, err
	}

	jsonData, err := json.Marshal(response.Data[0])
	if err != nil {
		return &workloadResourceDefinition, err
	}

	if err = json.Unmarshal(jsonData, &workloadResourceDefinition); err != nil {
		return &workloadResourceDefinition, err
	}

	return &workloadResourceDefinition, nil
}

// UpdateWorkloadResourceDefinition creates a new workload resource definition
func UpdateWorkloadResourceDefinition(id uint, jsonWorkloadResourceDefinition []byte, apiAddr, apiToken string) (*v0.WorkloadResourceDefinition, error) {
	var workloadResourceDefinition v0.WorkloadResourceDefinition

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/workload_resource_definitions/%d", apiAddr, ApiVersion, id),
		apiToken,
		http.MethodPatch,
		bytes.NewBuffer(jsonWorkloadResourceDefinition),
		http.StatusOK,
	)
	if err != nil {
		return &workloadResourceDefinition, err
	}

	jsonData, err := json.Marshal(response.Data[0])
	if err != nil {
		return &workloadResourceDefinition, err
	}

	if err = json.Unmarshal(jsonData, &workloadResourceDefinition); err != nil {
		return &workloadResourceDefinition, err
	}

	return &workloadResourceDefinition, nil
}

// GetWorkloadInstanceByID feteches a workload instance by ID
func GetWorkloadInstanceByID(id uint, apiAddr, apiToken string) (*v0.WorkloadInstance, error) {
	var workloadInstance v0.WorkloadInstance

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/workload_instances/%d", apiAddr, ApiVersion, id),
		apiToken,
		http.MethodGet,
		new(bytes.Buffer),
		http.StatusOK,
	)
	if err != nil {
		return &workloadInstance, err
	}

	jsonData, err := json.Marshal(response.Data[0])
	if err != nil {
		return &workloadInstance, err
	}

	if err = json.Unmarshal(jsonData, &workloadInstance); err != nil {
		return &workloadInstance, err
	}

	return &workloadInstance, nil
}

// GetWorkloadInstanceByName feteches a workload instance by name
func GetWorkloadInstanceByName(name, apiAddr, apiToken string) (*v0.WorkloadInstance, error) {
	var workloadInstances []v0.WorkloadInstance

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/workload_instances?name=%s", apiAddr, ApiVersion, name),
		apiToken,
		http.MethodGet,
		new(bytes.Buffer),
		http.StatusOK,
	)
	if err != nil {
		return &v0.WorkloadInstance{}, err
	}

	jsonData, err := json.Marshal(response.Data)
	if err != nil {
		return &v0.WorkloadInstance{}, err
	}

	if err = json.Unmarshal(jsonData, &workloadInstances); err != nil {
		return &v0.WorkloadInstance{}, err
	}

	switch {
	case len(workloadInstances) < 1:
		return &v0.WorkloadInstance{}, errors.New(fmt.Sprintf("no workload definitions with name %s", name))
	case len(workloadInstances) > 1:
		return &v0.WorkloadInstance{}, errors.New(fmt.Sprintf("more than one workload definition with name %s returned", name))
	}

	return &workloadInstances[0], nil
}

// CreateWorkloadInstance creates a new workload instance
func CreateWorkloadInstance(jsonWorkloadInstance []byte, apiAddr, apiToken string) (*v0.WorkloadInstance, error) {
	var workloadInstance v0.WorkloadInstance

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/workload_instances", apiAddr, ApiVersion),
		apiToken,
		http.MethodGet,
		bytes.NewBuffer(jsonWorkloadInstance),
		http.StatusCreated,
	)
	if err != nil {
		return &workloadInstance, err
	}

	jsonData, err := json.Marshal(response.Data[0])
	if err != nil {
		return &workloadInstance, err
	}

	if err = json.Unmarshal(jsonData, &workloadInstance); err != nil {
		return &workloadInstance, err
	}

	return &workloadInstance, nil
}

// UpdateWorkloadInstance creates a new workload instance
func UpdateWorkloadInstance(id uint, jsonWorkloadInstance []byte, apiAddr, apiToken string) (*v0.WorkloadInstance, error) {
	var workloadInstance v0.WorkloadInstance

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/workload_instances/%d", apiAddr, ApiVersion, id),
		apiToken,
		http.MethodPatch,
		bytes.NewBuffer(jsonWorkloadInstance),
		http.StatusOK,
	)
	if err != nil {
		return &workloadInstance, err
	}

	jsonData, err := json.Marshal(response.Data[0])
	if err != nil {
		return &workloadInstance, err
	}

	if err = json.Unmarshal(jsonData, &workloadInstance); err != nil {
		return &workloadInstance, err
	}

	return &workloadInstance, nil
}

// GetWorkloadResourceInstanceByID feteches a workload resource instance by ID
func GetWorkloadResourceInstanceByID(id uint, apiAddr, apiToken string) (*v0.WorkloadResourceInstance, error) {
	var workloadResourceInstance v0.WorkloadResourceInstance

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/workload_resource_instances/%d", apiAddr, ApiVersion, id),
		apiToken,
		http.MethodGet,
		new(bytes.Buffer),
		http.StatusOK,
	)
	if err != nil {
		return &workloadResourceInstance, err
	}

	jsonData, err := json.Marshal(response.Data[0])
	if err != nil {
		return &workloadResourceInstance, err
	}

	if err = json.Unmarshal(jsonData, &workloadResourceInstance); err != nil {
		return &workloadResourceInstance, err
	}

	return &workloadResourceInstance, nil
}

// GetWorkloadResourceInstanceByName feteches a workload resource instance by name
func GetWorkloadResourceInstanceByName(name, apiAddr, apiToken string) (*v0.WorkloadResourceInstance, error) {
	var workloadResourceInstances []v0.WorkloadResourceInstance

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/workload_resource_instances?name=%s", apiAddr, ApiVersion, name),
		apiToken,
		http.MethodGet,
		new(bytes.Buffer),
		http.StatusOK,
	)
	if err != nil {
		return &v0.WorkloadResourceInstance{}, err
	}

	jsonData, err := json.Marshal(response.Data)
	if err != nil {
		return &v0.WorkloadResourceInstance{}, err
	}

	if err = json.Unmarshal(jsonData, &workloadResourceInstances); err != nil {
		return &v0.WorkloadResourceInstance{}, err
	}

	switch {
	case len(workloadResourceInstances) < 1:
		return &v0.WorkloadResourceInstance{}, errors.New(fmt.Sprintf("no workload definitions with name %s", name))
	case len(workloadResourceInstances) > 1:
		return &v0.WorkloadResourceInstance{}, errors.New(fmt.Sprintf("more than one workload definition with name %s returned", name))
	}

	return &workloadResourceInstances[0], nil
}

// CreateWorkloadResourceInstance creates a new workload resource instance
func CreateWorkloadResourceInstance(jsonWorkloadResourceInstance []byte, apiAddr, apiToken string) (*v0.WorkloadResourceInstance, error) {
	var workloadResourceInstance v0.WorkloadResourceInstance

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/workload_resource_instances", apiAddr, ApiVersion),
		apiToken,
		http.MethodGet,
		bytes.NewBuffer(jsonWorkloadResourceInstance),
		http.StatusCreated,
	)
	if err != nil {
		return &workloadResourceInstance, err
	}

	jsonData, err := json.Marshal(response.Data[0])
	if err != nil {
		return &workloadResourceInstance, err
	}

	if err = json.Unmarshal(jsonData, &workloadResourceInstance); err != nil {
		return &workloadResourceInstance, err
	}

	return &workloadResourceInstance, nil
}

// UpdateWorkloadResourceInstance creates a new workload resource instance
func UpdateWorkloadResourceInstance(id uint, jsonWorkloadResourceInstance []byte, apiAddr, apiToken string) (*v0.WorkloadResourceInstance, error) {
	var workloadResourceInstance v0.WorkloadResourceInstance

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/workload_resource_instances/%d", apiAddr, ApiVersion, id),
		apiToken,
		http.MethodPatch,
		bytes.NewBuffer(jsonWorkloadResourceInstance),
		http.StatusOK,
	)
	if err != nil {
		return &workloadResourceInstance, err
	}

	jsonData, err := json.Marshal(response.Data[0])
	if err != nil {
		return &workloadResourceInstance, err
	}

	if err = json.Unmarshal(jsonData, &workloadResourceInstance); err != nil {
		return &workloadResourceInstance, err
	}

	return &workloadResourceInstance, nil
}
