// generated by 'threeport-codegen api-model' - do not edit

package v0

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	v0 "github.com/threeport/threeport/pkg/api/v0"
	client "github.com/threeport/threeport/pkg/client"
	"net/http"
)

// GetUserByID feteches a user by ID
func GetUserByID(id uint, apiAddr, apiToken string) (*v0.User, error) {
	var user v0.User

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/users/%d", apiAddr, ApiVersion, id),
		apiToken,
		http.MethodGet,
		new(bytes.Buffer),
		http.StatusOK,
	)
	if err != nil {
		return &user, err
	}

	jsonData, err := json.Marshal(response.Data[0])
	if err != nil {
		return &user, err
	}

	if err = json.Unmarshal(jsonData, &user); err != nil {
		return &user, err
	}

	return &user, nil
}

// GetUserByName fetches a user by name
func GetUserByName(name, apiAddr, apiToken string) (*v0.User, error) {
	var users []v0.User

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/users?name=%s", apiAddr, ApiVersion, name),
		apiToken,
		http.MethodGet,
		new(bytes.Buffer),
		http.StatusOK,
	)
	if err != nil {
		return &v0.User{}, err
	}

	jsonData, err := json.Marshal(response.Data)
	if err != nil {
		return &v0.User{}, err
	}

	if err = json.Unmarshal(jsonData, &users); err != nil {
		return &v0.User{}, err
	}

	switch {
	case len(users) < 1:
		return &v0.User{}, errors.New(fmt.Sprintf("no workload definitions with name %s", name))
	case len(users) > 1:
		return &v0.User{}, errors.New(fmt.Sprintf("more than one workload definition with name %s returned", name))
	}

	return &users[0], nil
}

// CreateUser creates a new user
func CreateUser(user *v0.User, apiAddr, apiToken string) (*v0.User, error) {
	jsonUser, err := client.MarshalObject(user)
	if err != nil {
		return user, err
	}

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/users", apiAddr, ApiVersion),
		apiToken,
		http.MethodPost,
		bytes.NewBuffer(jsonUser),
		http.StatusCreated,
	)
	if err != nil {
		return user, err
	}

	jsonData, err := json.Marshal(response.Data[0])
	if err != nil {
		return user, err
	}

	if err = json.Unmarshal(jsonData, &user); err != nil {
		return user, err
	}

	return user, nil
}

// UpdateUser updates a user
func UpdateUser(user *v0.User, apiAddr, apiToken string, id uint) (*v0.User, error) {
	jsonUser, err := client.MarshalObject(user)
	if err != nil {
		return user, err
	}

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/users/%d", apiAddr, ApiVersion, id),
		apiToken,
		http.MethodPatch,
		bytes.NewBuffer(jsonUser),
		http.StatusOK,
	)
	if err != nil {
		return user, err
	}

	jsonData, err := json.Marshal(response.Data[0])
	if err != nil {
		return user, err
	}

	if err = json.Unmarshal(jsonData, &user); err != nil {
		return user, err
	}

	return user, nil
}

// GetCompanyByID feteches a company by ID
func GetCompanyByID(id uint, apiAddr, apiToken string) (*v0.Company, error) {
	var company v0.Company

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/companies/%d", apiAddr, ApiVersion, id),
		apiToken,
		http.MethodGet,
		new(bytes.Buffer),
		http.StatusOK,
	)
	if err != nil {
		return &company, err
	}

	jsonData, err := json.Marshal(response.Data[0])
	if err != nil {
		return &company, err
	}

	if err = json.Unmarshal(jsonData, &company); err != nil {
		return &company, err
	}

	return &company, nil
}

// GetCompanyByName fetches a company by name
func GetCompanyByName(name, apiAddr, apiToken string) (*v0.Company, error) {
	var companies []v0.Company

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/companies?name=%s", apiAddr, ApiVersion, name),
		apiToken,
		http.MethodGet,
		new(bytes.Buffer),
		http.StatusOK,
	)
	if err != nil {
		return &v0.Company{}, err
	}

	jsonData, err := json.Marshal(response.Data)
	if err != nil {
		return &v0.Company{}, err
	}

	if err = json.Unmarshal(jsonData, &companies); err != nil {
		return &v0.Company{}, err
	}

	switch {
	case len(companies) < 1:
		return &v0.Company{}, errors.New(fmt.Sprintf("no workload definitions with name %s", name))
	case len(companies) > 1:
		return &v0.Company{}, errors.New(fmt.Sprintf("more than one workload definition with name %s returned", name))
	}

	return &companies[0], nil
}

// CreateCompany creates a new company
func CreateCompany(company *v0.Company, apiAddr, apiToken string) (*v0.Company, error) {
	jsonCompany, err := client.MarshalObject(company)
	if err != nil {
		return company, err
	}

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/companies", apiAddr, ApiVersion),
		apiToken,
		http.MethodPost,
		bytes.NewBuffer(jsonCompany),
		http.StatusCreated,
	)
	if err != nil {
		return company, err
	}

	jsonData, err := json.Marshal(response.Data[0])
	if err != nil {
		return company, err
	}

	if err = json.Unmarshal(jsonData, &company); err != nil {
		return company, err
	}

	return company, nil
}

// UpdateCompany updates a company
func UpdateCompany(company *v0.Company, apiAddr, apiToken string, id uint) (*v0.Company, error) {
	jsonCompany, err := client.MarshalObject(company)
	if err != nil {
		return company, err
	}

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/companies/%d", apiAddr, ApiVersion, id),
		apiToken,
		http.MethodPatch,
		bytes.NewBuffer(jsonCompany),
		http.StatusOK,
	)
	if err != nil {
		return company, err
	}

	jsonData, err := json.Marshal(response.Data[0])
	if err != nil {
		return company, err
	}

	if err = json.Unmarshal(jsonData, &company); err != nil {
		return company, err
	}

	return company, nil
}
