// generated by 'threeport-codegen api-model' - do not edit

package v0

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	v0 "github.com/threeport/threeport/pkg/api/v0"
	client "github.com/threeport/threeport/pkg/client"
	"net/http"
)

// GetProfileByID feteches a profile by ID
func GetProfileByID(id uint, apiAddr, apiToken string) (*v0.Profile, error) {
	var profile v0.Profile

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/profiles/%d", apiAddr, ApiVersion, id),
		apiToken,
		http.MethodGet,
		new(bytes.Buffer),
		http.StatusOK,
	)
	if err != nil {
		return &profile, err
	}

	jsonData, err := json.Marshal(response.Data[0])
	if err != nil {
		return &profile, err
	}

	if err = json.Unmarshal(jsonData, &profile); err != nil {
		return &profile, err
	}

	return &profile, nil
}

// GetProfileByName fetches a profile by name
func GetProfileByName(name, apiAddr, apiToken string) (*v0.Profile, error) {
	var profiles []v0.Profile

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/profiles?name=%s", apiAddr, ApiVersion, name),
		apiToken,
		http.MethodGet,
		new(bytes.Buffer),
		http.StatusOK,
	)
	if err != nil {
		return &v0.Profile{}, err
	}

	jsonData, err := json.Marshal(response.Data)
	if err != nil {
		return &v0.Profile{}, err
	}

	if err = json.Unmarshal(jsonData, &profiles); err != nil {
		return &v0.Profile{}, err
	}

	switch {
	case len(profiles) < 1:
		return &v0.Profile{}, errors.New(fmt.Sprintf("no workload definitions with name %s", name))
	case len(profiles) > 1:
		return &v0.Profile{}, errors.New(fmt.Sprintf("more than one workload definition with name %s returned", name))
	}

	return &profiles[0], nil
}

// CreateProfile creates a new profile
func CreateProfile(profile *v0.Profile, apiAddr, apiToken string) (*v0.Profile, error) {
	jsonProfile, err := client.MarshalObject(profile)
	if err != nil {
		return profile, err
	}

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/profiles", apiAddr, ApiVersion),
		apiToken,
		http.MethodPost,
		bytes.NewBuffer(jsonProfile),
		http.StatusCreated,
	)
	if err != nil {
		return profile, err
	}

	jsonData, err := json.Marshal(response.Data[0])
	if err != nil {
		return profile, err
	}

	if err = json.Unmarshal(jsonData, &profile); err != nil {
		return profile, err
	}

	return profile, nil
}

// UpdateProfile updates a profile
func UpdateProfile(profile *v0.Profile, apiAddr, apiToken string) (*v0.Profile, error) {
	jsonProfile, err := client.MarshalObject(profile)
	if err != nil {
		return profile, err
	}

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/profiles/%d", apiAddr, ApiVersion, *profile.ID),
		apiToken,
		http.MethodPatch,
		bytes.NewBuffer(jsonProfile),
		http.StatusOK,
	)
	if err != nil {
		return profile, err
	}

	jsonData, err := json.Marshal(response.Data[0])
	if err != nil {
		return profile, err
	}

	if err = json.Unmarshal(jsonData, &profile); err != nil {
		return profile, err
	}

	return profile, nil
}

// GetTierByID feteches a tier by ID
func GetTierByID(id uint, apiAddr, apiToken string) (*v0.Tier, error) {
	var tier v0.Tier

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/tiers/%d", apiAddr, ApiVersion, id),
		apiToken,
		http.MethodGet,
		new(bytes.Buffer),
		http.StatusOK,
	)
	if err != nil {
		return &tier, err
	}

	jsonData, err := json.Marshal(response.Data[0])
	if err != nil {
		return &tier, err
	}

	if err = json.Unmarshal(jsonData, &tier); err != nil {
		return &tier, err
	}

	return &tier, nil
}

// GetTierByName fetches a tier by name
func GetTierByName(name, apiAddr, apiToken string) (*v0.Tier, error) {
	var tiers []v0.Tier

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/tiers?name=%s", apiAddr, ApiVersion, name),
		apiToken,
		http.MethodGet,
		new(bytes.Buffer),
		http.StatusOK,
	)
	if err != nil {
		return &v0.Tier{}, err
	}

	jsonData, err := json.Marshal(response.Data)
	if err != nil {
		return &v0.Tier{}, err
	}

	if err = json.Unmarshal(jsonData, &tiers); err != nil {
		return &v0.Tier{}, err
	}

	switch {
	case len(tiers) < 1:
		return &v0.Tier{}, errors.New(fmt.Sprintf("no workload definitions with name %s", name))
	case len(tiers) > 1:
		return &v0.Tier{}, errors.New(fmt.Sprintf("more than one workload definition with name %s returned", name))
	}

	return &tiers[0], nil
}

// CreateTier creates a new tier
func CreateTier(tier *v0.Tier, apiAddr, apiToken string) (*v0.Tier, error) {
	jsonTier, err := client.MarshalObject(tier)
	if err != nil {
		return tier, err
	}

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/tiers", apiAddr, ApiVersion),
		apiToken,
		http.MethodPost,
		bytes.NewBuffer(jsonTier),
		http.StatusCreated,
	)
	if err != nil {
		return tier, err
	}

	jsonData, err := json.Marshal(response.Data[0])
	if err != nil {
		return tier, err
	}

	if err = json.Unmarshal(jsonData, &tier); err != nil {
		return tier, err
	}

	return tier, nil
}

// UpdateTier updates a tier
func UpdateTier(tier *v0.Tier, apiAddr, apiToken string) (*v0.Tier, error) {
	jsonTier, err := client.MarshalObject(tier)
	if err != nil {
		return tier, err
	}

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/tiers/%d", apiAddr, ApiVersion, *tier.ID),
		apiToken,
		http.MethodPatch,
		bytes.NewBuffer(jsonTier),
		http.StatusOK,
	)
	if err != nil {
		return tier, err
	}

	jsonData, err := json.Marshal(response.Data[0])
	if err != nil {
		return tier, err
	}

	if err = json.Unmarshal(jsonData, &tier); err != nil {
		return tier, err
	}

	return tier, nil
}
