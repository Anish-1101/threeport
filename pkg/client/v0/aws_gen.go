// generated by 'threeport-codegen api-model' - do not edit

package v0

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	v0 "github.com/threeport/threeport/pkg/api/v0"
	client "github.com/threeport/threeport/pkg/client"
	"net/http"
)

// GetAwsAccountByID feteches a aws account by ID
func GetAwsAccountByID(id uint, apiAddr, apiToken string) (*v0.AwsAccount, error) {
	var awsAccount v0.AwsAccount

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/aws-accounts/%d", apiAddr, ApiVersion, id),
		apiToken,
		http.MethodGet,
		new(bytes.Buffer),
		http.StatusOK,
	)
	if err != nil {
		return &awsAccount, err
	}

	jsonData, err := json.Marshal(response.Data[0])
	if err != nil {
		return &awsAccount, err
	}

	if err = json.Unmarshal(jsonData, &awsAccount); err != nil {
		return &awsAccount, err
	}

	return &awsAccount, nil
}

// GetAwsAccountByName feteches a aws account by name
func GetAwsAccountByName(name, apiAddr, apiToken string) (*v0.AwsAccount, error) {
	var awsAccounts []v0.AwsAccount

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/aws-accounts?name=%s", apiAddr, ApiVersion, name),
		apiToken,
		http.MethodGet,
		new(bytes.Buffer),
		http.StatusOK,
	)
	if err != nil {
		return &v0.AwsAccount{}, err
	}

	jsonData, err := json.Marshal(response.Data)
	if err != nil {
		return &v0.AwsAccount{}, err
	}

	if err = json.Unmarshal(jsonData, &awsAccounts); err != nil {
		return &v0.AwsAccount{}, err
	}

	switch {
	case len(awsAccounts) < 1:
		return &v0.AwsAccount{}, errors.New(fmt.Sprintf("no workload definitions with name %s", name))
	case len(awsAccounts) > 1:
		return &v0.AwsAccount{}, errors.New(fmt.Sprintf("more than one workload definition with name %s returned", name))
	}

	return &awsAccounts[0], nil
}

// CreateAwsAccount creates a new aws account
func CreateAwsAccount(awsAccount *v0.AwsAccount, apiAddr, apiToken string) (*v0.AwsAccount, error) {
	jsonAwsAccount, err := client.MarshalObject(awsAccount)
	if err != nil {
		return awsAccount, err
	}

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/aws-accounts", apiAddr, ApiVersion),
		apiToken,
		http.MethodGet,
		bytes.NewBuffer(jsonAwsAccount),
		http.StatusCreated,
	)
	if err != nil {
		return awsAccount, err
	}

	jsonData, err := json.Marshal(response.Data[0])
	if err != nil {
		return awsAccount, err
	}

	if err = json.Unmarshal(jsonData, &awsAccount); err != nil {
		return awsAccount, err
	}

	return awsAccount, nil
}

// UpdateAwsAccount updates a aws account
func UpdateAwsAccount(awsAccount *v0.AwsAccount, apiAddr, apiToken string) (*v0.AwsAccount, error) {
	jsonAwsAccount, err := client.MarshalObject(awsAccount)
	if err != nil {
		return awsAccount, err
	}

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/aws-accounts/%d", apiAddr, ApiVersion, *awsAccount.ID),
		apiToken,
		http.MethodPatch,
		bytes.NewBuffer(jsonAwsAccount),
		http.StatusOK,
	)
	if err != nil {
		return awsAccount, err
	}

	jsonData, err := json.Marshal(response.Data[0])
	if err != nil {
		return awsAccount, err
	}

	if err = json.Unmarshal(jsonData, &awsAccount); err != nil {
		return awsAccount, err
	}

	return awsAccount, nil
}

// GetAwsEksClusterDefinitionByID feteches a aws eks cluster definition by ID
func GetAwsEksClusterDefinitionByID(id uint, apiAddr, apiToken string) (*v0.AwsEksClusterDefinition, error) {
	var awsEksClusterDefinition v0.AwsEksClusterDefinition

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/aws-eks-cluster-definitions/%d", apiAddr, ApiVersion, id),
		apiToken,
		http.MethodGet,
		new(bytes.Buffer),
		http.StatusOK,
	)
	if err != nil {
		return &awsEksClusterDefinition, err
	}

	jsonData, err := json.Marshal(response.Data[0])
	if err != nil {
		return &awsEksClusterDefinition, err
	}

	if err = json.Unmarshal(jsonData, &awsEksClusterDefinition); err != nil {
		return &awsEksClusterDefinition, err
	}

	return &awsEksClusterDefinition, nil
}

// GetAwsEksClusterDefinitionByName feteches a aws eks cluster definition by name
func GetAwsEksClusterDefinitionByName(name, apiAddr, apiToken string) (*v0.AwsEksClusterDefinition, error) {
	var awsEksClusterDefinitions []v0.AwsEksClusterDefinition

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/aws-eks-cluster-definitions?name=%s", apiAddr, ApiVersion, name),
		apiToken,
		http.MethodGet,
		new(bytes.Buffer),
		http.StatusOK,
	)
	if err != nil {
		return &v0.AwsEksClusterDefinition{}, err
	}

	jsonData, err := json.Marshal(response.Data)
	if err != nil {
		return &v0.AwsEksClusterDefinition{}, err
	}

	if err = json.Unmarshal(jsonData, &awsEksClusterDefinitions); err != nil {
		return &v0.AwsEksClusterDefinition{}, err
	}

	switch {
	case len(awsEksClusterDefinitions) < 1:
		return &v0.AwsEksClusterDefinition{}, errors.New(fmt.Sprintf("no workload definitions with name %s", name))
	case len(awsEksClusterDefinitions) > 1:
		return &v0.AwsEksClusterDefinition{}, errors.New(fmt.Sprintf("more than one workload definition with name %s returned", name))
	}

	return &awsEksClusterDefinitions[0], nil
}

// CreateAwsEksClusterDefinition creates a new aws eks cluster definition
func CreateAwsEksClusterDefinition(awsEksClusterDefinition *v0.AwsEksClusterDefinition, apiAddr, apiToken string) (*v0.AwsEksClusterDefinition, error) {
	jsonAwsEksClusterDefinition, err := client.MarshalObject(awsEksClusterDefinition)
	if err != nil {
		return awsEksClusterDefinition, err
	}

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/aws-eks-cluster-definitions", apiAddr, ApiVersion),
		apiToken,
		http.MethodGet,
		bytes.NewBuffer(jsonAwsEksClusterDefinition),
		http.StatusCreated,
	)
	if err != nil {
		return awsEksClusterDefinition, err
	}

	jsonData, err := json.Marshal(response.Data[0])
	if err != nil {
		return awsEksClusterDefinition, err
	}

	if err = json.Unmarshal(jsonData, &awsEksClusterDefinition); err != nil {
		return awsEksClusterDefinition, err
	}

	return awsEksClusterDefinition, nil
}

// UpdateAwsEksClusterDefinition updates a aws eks cluster definition
func UpdateAwsEksClusterDefinition(awsEksClusterDefinition *v0.AwsEksClusterDefinition, apiAddr, apiToken string) (*v0.AwsEksClusterDefinition, error) {
	jsonAwsEksClusterDefinition, err := client.MarshalObject(awsEksClusterDefinition)
	if err != nil {
		return awsEksClusterDefinition, err
	}

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/aws-eks-cluster-definitions/%d", apiAddr, ApiVersion, *awsEksClusterDefinition.ID),
		apiToken,
		http.MethodPatch,
		bytes.NewBuffer(jsonAwsEksClusterDefinition),
		http.StatusOK,
	)
	if err != nil {
		return awsEksClusterDefinition, err
	}

	jsonData, err := json.Marshal(response.Data[0])
	if err != nil {
		return awsEksClusterDefinition, err
	}

	if err = json.Unmarshal(jsonData, &awsEksClusterDefinition); err != nil {
		return awsEksClusterDefinition, err
	}

	return awsEksClusterDefinition, nil
}

// GetAwsEksClusterInstanceByID feteches a aws eks cluster instance by ID
func GetAwsEksClusterInstanceByID(id uint, apiAddr, apiToken string) (*v0.AwsEksClusterInstance, error) {
	var awsEksClusterInstance v0.AwsEksClusterInstance

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/aws-eks-cluster-instances/%d", apiAddr, ApiVersion, id),
		apiToken,
		http.MethodGet,
		new(bytes.Buffer),
		http.StatusOK,
	)
	if err != nil {
		return &awsEksClusterInstance, err
	}

	jsonData, err := json.Marshal(response.Data[0])
	if err != nil {
		return &awsEksClusterInstance, err
	}

	if err = json.Unmarshal(jsonData, &awsEksClusterInstance); err != nil {
		return &awsEksClusterInstance, err
	}

	return &awsEksClusterInstance, nil
}

// GetAwsEksClusterInstanceByName feteches a aws eks cluster instance by name
func GetAwsEksClusterInstanceByName(name, apiAddr, apiToken string) (*v0.AwsEksClusterInstance, error) {
	var awsEksClusterInstances []v0.AwsEksClusterInstance

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/aws-eks-cluster-instances?name=%s", apiAddr, ApiVersion, name),
		apiToken,
		http.MethodGet,
		new(bytes.Buffer),
		http.StatusOK,
	)
	if err != nil {
		return &v0.AwsEksClusterInstance{}, err
	}

	jsonData, err := json.Marshal(response.Data)
	if err != nil {
		return &v0.AwsEksClusterInstance{}, err
	}

	if err = json.Unmarshal(jsonData, &awsEksClusterInstances); err != nil {
		return &v0.AwsEksClusterInstance{}, err
	}

	switch {
	case len(awsEksClusterInstances) < 1:
		return &v0.AwsEksClusterInstance{}, errors.New(fmt.Sprintf("no workload definitions with name %s", name))
	case len(awsEksClusterInstances) > 1:
		return &v0.AwsEksClusterInstance{}, errors.New(fmt.Sprintf("more than one workload definition with name %s returned", name))
	}

	return &awsEksClusterInstances[0], nil
}

// CreateAwsEksClusterInstance creates a new aws eks cluster instance
func CreateAwsEksClusterInstance(awsEksClusterInstance *v0.AwsEksClusterInstance, apiAddr, apiToken string) (*v0.AwsEksClusterInstance, error) {
	jsonAwsEksClusterInstance, err := client.MarshalObject(awsEksClusterInstance)
	if err != nil {
		return awsEksClusterInstance, err
	}

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/aws-eks-cluster-instances", apiAddr, ApiVersion),
		apiToken,
		http.MethodGet,
		bytes.NewBuffer(jsonAwsEksClusterInstance),
		http.StatusCreated,
	)
	if err != nil {
		return awsEksClusterInstance, err
	}

	jsonData, err := json.Marshal(response.Data[0])
	if err != nil {
		return awsEksClusterInstance, err
	}

	if err = json.Unmarshal(jsonData, &awsEksClusterInstance); err != nil {
		return awsEksClusterInstance, err
	}

	return awsEksClusterInstance, nil
}

// UpdateAwsEksClusterInstance updates a aws eks cluster instance
func UpdateAwsEksClusterInstance(awsEksClusterInstance *v0.AwsEksClusterInstance, apiAddr, apiToken string) (*v0.AwsEksClusterInstance, error) {
	jsonAwsEksClusterInstance, err := client.MarshalObject(awsEksClusterInstance)
	if err != nil {
		return awsEksClusterInstance, err
	}

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/aws-eks-cluster-instances/%d", apiAddr, ApiVersion, *awsEksClusterInstance.ID),
		apiToken,
		http.MethodPatch,
		bytes.NewBuffer(jsonAwsEksClusterInstance),
		http.StatusOK,
	)
	if err != nil {
		return awsEksClusterInstance, err
	}

	jsonData, err := json.Marshal(response.Data[0])
	if err != nil {
		return awsEksClusterInstance, err
	}

	if err = json.Unmarshal(jsonData, &awsEksClusterInstance); err != nil {
		return awsEksClusterInstance, err
	}

	return awsEksClusterInstance, nil
}

// GetAwsRelationalDatabaseDefinitionByID feteches a aws relational database definition by ID
func GetAwsRelationalDatabaseDefinitionByID(id uint, apiAddr, apiToken string) (*v0.AwsRelationalDatabaseDefinition, error) {
	var awsRelationalDatabaseDefinition v0.AwsRelationalDatabaseDefinition

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/aws-relational-database-definitions/%d", apiAddr, ApiVersion, id),
		apiToken,
		http.MethodGet,
		new(bytes.Buffer),
		http.StatusOK,
	)
	if err != nil {
		return &awsRelationalDatabaseDefinition, err
	}

	jsonData, err := json.Marshal(response.Data[0])
	if err != nil {
		return &awsRelationalDatabaseDefinition, err
	}

	if err = json.Unmarshal(jsonData, &awsRelationalDatabaseDefinition); err != nil {
		return &awsRelationalDatabaseDefinition, err
	}

	return &awsRelationalDatabaseDefinition, nil
}

// GetAwsRelationalDatabaseDefinitionByName feteches a aws relational database definition by name
func GetAwsRelationalDatabaseDefinitionByName(name, apiAddr, apiToken string) (*v0.AwsRelationalDatabaseDefinition, error) {
	var awsRelationalDatabaseDefinitions []v0.AwsRelationalDatabaseDefinition

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/aws-relational-database-definitions?name=%s", apiAddr, ApiVersion, name),
		apiToken,
		http.MethodGet,
		new(bytes.Buffer),
		http.StatusOK,
	)
	if err != nil {
		return &v0.AwsRelationalDatabaseDefinition{}, err
	}

	jsonData, err := json.Marshal(response.Data)
	if err != nil {
		return &v0.AwsRelationalDatabaseDefinition{}, err
	}

	if err = json.Unmarshal(jsonData, &awsRelationalDatabaseDefinitions); err != nil {
		return &v0.AwsRelationalDatabaseDefinition{}, err
	}

	switch {
	case len(awsRelationalDatabaseDefinitions) < 1:
		return &v0.AwsRelationalDatabaseDefinition{}, errors.New(fmt.Sprintf("no workload definitions with name %s", name))
	case len(awsRelationalDatabaseDefinitions) > 1:
		return &v0.AwsRelationalDatabaseDefinition{}, errors.New(fmt.Sprintf("more than one workload definition with name %s returned", name))
	}

	return &awsRelationalDatabaseDefinitions[0], nil
}

// CreateAwsRelationalDatabaseDefinition creates a new aws relational database definition
func CreateAwsRelationalDatabaseDefinition(awsRelationalDatabaseDefinition *v0.AwsRelationalDatabaseDefinition, apiAddr, apiToken string) (*v0.AwsRelationalDatabaseDefinition, error) {
	jsonAwsRelationalDatabaseDefinition, err := client.MarshalObject(awsRelationalDatabaseDefinition)
	if err != nil {
		return awsRelationalDatabaseDefinition, err
	}

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/aws-relational-database-definitions", apiAddr, ApiVersion),
		apiToken,
		http.MethodGet,
		bytes.NewBuffer(jsonAwsRelationalDatabaseDefinition),
		http.StatusCreated,
	)
	if err != nil {
		return awsRelationalDatabaseDefinition, err
	}

	jsonData, err := json.Marshal(response.Data[0])
	if err != nil {
		return awsRelationalDatabaseDefinition, err
	}

	if err = json.Unmarshal(jsonData, &awsRelationalDatabaseDefinition); err != nil {
		return awsRelationalDatabaseDefinition, err
	}

	return awsRelationalDatabaseDefinition, nil
}

// UpdateAwsRelationalDatabaseDefinition updates a aws relational database definition
func UpdateAwsRelationalDatabaseDefinition(awsRelationalDatabaseDefinition *v0.AwsRelationalDatabaseDefinition, apiAddr, apiToken string) (*v0.AwsRelationalDatabaseDefinition, error) {
	jsonAwsRelationalDatabaseDefinition, err := client.MarshalObject(awsRelationalDatabaseDefinition)
	if err != nil {
		return awsRelationalDatabaseDefinition, err
	}

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/aws-relational-database-definitions/%d", apiAddr, ApiVersion, *awsRelationalDatabaseDefinition.ID),
		apiToken,
		http.MethodPatch,
		bytes.NewBuffer(jsonAwsRelationalDatabaseDefinition),
		http.StatusOK,
	)
	if err != nil {
		return awsRelationalDatabaseDefinition, err
	}

	jsonData, err := json.Marshal(response.Data[0])
	if err != nil {
		return awsRelationalDatabaseDefinition, err
	}

	if err = json.Unmarshal(jsonData, &awsRelationalDatabaseDefinition); err != nil {
		return awsRelationalDatabaseDefinition, err
	}

	return awsRelationalDatabaseDefinition, nil
}

// GetAwsRelationalDatabaseInstanceByID feteches a aws relational database instance by ID
func GetAwsRelationalDatabaseInstanceByID(id uint, apiAddr, apiToken string) (*v0.AwsRelationalDatabaseInstance, error) {
	var awsRelationalDatabaseInstance v0.AwsRelationalDatabaseInstance

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/aws-relational-database-instances/%d", apiAddr, ApiVersion, id),
		apiToken,
		http.MethodGet,
		new(bytes.Buffer),
		http.StatusOK,
	)
	if err != nil {
		return &awsRelationalDatabaseInstance, err
	}

	jsonData, err := json.Marshal(response.Data[0])
	if err != nil {
		return &awsRelationalDatabaseInstance, err
	}

	if err = json.Unmarshal(jsonData, &awsRelationalDatabaseInstance); err != nil {
		return &awsRelationalDatabaseInstance, err
	}

	return &awsRelationalDatabaseInstance, nil
}

// GetAwsRelationalDatabaseInstanceByName feteches a aws relational database instance by name
func GetAwsRelationalDatabaseInstanceByName(name, apiAddr, apiToken string) (*v0.AwsRelationalDatabaseInstance, error) {
	var awsRelationalDatabaseInstances []v0.AwsRelationalDatabaseInstance

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/aws-relational-database-instances?name=%s", apiAddr, ApiVersion, name),
		apiToken,
		http.MethodGet,
		new(bytes.Buffer),
		http.StatusOK,
	)
	if err != nil {
		return &v0.AwsRelationalDatabaseInstance{}, err
	}

	jsonData, err := json.Marshal(response.Data)
	if err != nil {
		return &v0.AwsRelationalDatabaseInstance{}, err
	}

	if err = json.Unmarshal(jsonData, &awsRelationalDatabaseInstances); err != nil {
		return &v0.AwsRelationalDatabaseInstance{}, err
	}

	switch {
	case len(awsRelationalDatabaseInstances) < 1:
		return &v0.AwsRelationalDatabaseInstance{}, errors.New(fmt.Sprintf("no workload definitions with name %s", name))
	case len(awsRelationalDatabaseInstances) > 1:
		return &v0.AwsRelationalDatabaseInstance{}, errors.New(fmt.Sprintf("more than one workload definition with name %s returned", name))
	}

	return &awsRelationalDatabaseInstances[0], nil
}

// CreateAwsRelationalDatabaseInstance creates a new aws relational database instance
func CreateAwsRelationalDatabaseInstance(awsRelationalDatabaseInstance *v0.AwsRelationalDatabaseInstance, apiAddr, apiToken string) (*v0.AwsRelationalDatabaseInstance, error) {
	jsonAwsRelationalDatabaseInstance, err := client.MarshalObject(awsRelationalDatabaseInstance)
	if err != nil {
		return awsRelationalDatabaseInstance, err
	}

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/aws-relational-database-instances", apiAddr, ApiVersion),
		apiToken,
		http.MethodGet,
		bytes.NewBuffer(jsonAwsRelationalDatabaseInstance),
		http.StatusCreated,
	)
	if err != nil {
		return awsRelationalDatabaseInstance, err
	}

	jsonData, err := json.Marshal(response.Data[0])
	if err != nil {
		return awsRelationalDatabaseInstance, err
	}

	if err = json.Unmarshal(jsonData, &awsRelationalDatabaseInstance); err != nil {
		return awsRelationalDatabaseInstance, err
	}

	return awsRelationalDatabaseInstance, nil
}

// UpdateAwsRelationalDatabaseInstance updates a aws relational database instance
func UpdateAwsRelationalDatabaseInstance(awsRelationalDatabaseInstance *v0.AwsRelationalDatabaseInstance, apiAddr, apiToken string) (*v0.AwsRelationalDatabaseInstance, error) {
	jsonAwsRelationalDatabaseInstance, err := client.MarshalObject(awsRelationalDatabaseInstance)
	if err != nil {
		return awsRelationalDatabaseInstance, err
	}

	response, err := GetResponse(
		fmt.Sprintf("%s/%s/aws-relational-database-instances/%d", apiAddr, ApiVersion, *awsRelationalDatabaseInstance.ID),
		apiToken,
		http.MethodPatch,
		bytes.NewBuffer(jsonAwsRelationalDatabaseInstance),
		http.StatusOK,
	)
	if err != nil {
		return awsRelationalDatabaseInstance, err
	}

	jsonData, err := json.Marshal(response.Data[0])
	if err != nil {
		return awsRelationalDatabaseInstance, err
	}

	if err = json.Unmarshal(jsonData, &awsRelationalDatabaseInstance); err != nil {
		return awsRelationalDatabaseInstance, err
	}

	return awsRelationalDatabaseInstance, nil
}
