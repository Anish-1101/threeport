// generated by 'threeport-sdk gen' - do not edit

package v0

import (
	"encoding/json"
	"fmt"
	notifications "github.com/threeport/threeport/pkg/notifications/v0"
	"time"
)

const (
	ObjectTypeAzureAccount                        string = "AzureAccount"
	ObjectTypeAzureAksKubernetesRuntimeDefinition string = "AzureAksKubernetesRuntimeDefinition"
	ObjectTypeAzureAksKubernetesRuntimeInstance   string = "AzureAksKubernetesRuntimeInstance"
	ObjectTypeAzureRelationalDatabaseDefinition   string = "AzureRelationalDatabaseDefinition"
	ObjectTypeAzureRelationalDatabaseInstance     string = "AzureRelationalDatabaseInstance"

	PathAzureAccounts                        = "/v0/azure-accounts"
	PathAzureAksKubernetesRuntimeDefinitions = "/v0/azure-aks-kubernetes-runtime-definitions"
	PathAzureAksKubernetesRuntimeInstances   = "/v0/azure-aks-kubernetes-runtime-instances"
	PathAzureRelationalDatabaseDefinitions   = "/v0/azure-relational-database-definitions"
	PathAzureRelationalDatabaseInstances     = "/v0/azure-relational-database-instances"
)

// NotificationPayload returns the notification payload that is delivered to the
// controller when a change is made.  It includes the object as presented by the
// client when the change was made.
func (aa *AzureAccount) NotificationPayload(
	operation notifications.NotificationOperation,
	requeue bool,
	creationTime int64,
) (*[]byte, error) {
	notif := notifications.Notification{
		CreationTime:  &creationTime,
		Object:        aa,
		ObjectVersion: aa.GetVersion(),
		Operation:     operation,
	}

	payload, err := json.Marshal(notif)
	if err != nil {
		return &payload, fmt.Errorf("failed to marshal notification payload %+v: %w", aa, err)
	}

	return &payload, nil
}

// DecodeNotifObject takes the threeport object in the form of a
// map[string]interface and returns the typed object by marshalling into JSON
// and then unmarshalling into the typed object.  We are not using the
// mapstructure library here as that requires custom decode hooks to manage
// fields with non-native go types.
func (aa *AzureAccount) DecodeNotifObject(object interface{}) error {
	jsonObject, err := json.Marshal(object)
	if err != nil {
		return fmt.Errorf("failed to marshal object map from consumed notification message: %w", err)
	}
	if err := json.Unmarshal(jsonObject, &aa); err != nil {
		return fmt.Errorf("failed to unmarshal json object to typed object: %w", err)
	}
	return nil
}

// GetId returns the unique ID for the object.
func (aa *AzureAccount) GetId() uint {
	return *aa.ID
}

// Type returns the object type.
func (aa *AzureAccount) GetType() string {
	return "AzureAccount"
}

// Version returns the version of the API object.
func (aa *AzureAccount) GetVersion() string {
	return "v0"
}

// NotificationPayload returns the notification payload that is delivered to the
// controller when a change is made.  It includes the object as presented by the
// client when the change was made.
func (aakrd *AzureAksKubernetesRuntimeDefinition) NotificationPayload(
	operation notifications.NotificationOperation,
	requeue bool,
	creationTime int64,
) (*[]byte, error) {
	notif := notifications.Notification{
		CreationTime:  &creationTime,
		Object:        aakrd,
		ObjectVersion: aakrd.GetVersion(),
		Operation:     operation,
	}

	payload, err := json.Marshal(notif)
	if err != nil {
		return &payload, fmt.Errorf("failed to marshal notification payload %+v: %w", aakrd, err)
	}

	return &payload, nil
}

// DecodeNotifObject takes the threeport object in the form of a
// map[string]interface and returns the typed object by marshalling into JSON
// and then unmarshalling into the typed object.  We are not using the
// mapstructure library here as that requires custom decode hooks to manage
// fields with non-native go types.
func (aakrd *AzureAksKubernetesRuntimeDefinition) DecodeNotifObject(object interface{}) error {
	jsonObject, err := json.Marshal(object)
	if err != nil {
		return fmt.Errorf("failed to marshal object map from consumed notification message: %w", err)
	}
	if err := json.Unmarshal(jsonObject, &aakrd); err != nil {
		return fmt.Errorf("failed to unmarshal json object to typed object: %w", err)
	}
	return nil
}

// GetId returns the unique ID for the object.
func (aakrd *AzureAksKubernetesRuntimeDefinition) GetId() uint {
	return *aakrd.ID
}

// Type returns the object type.
func (aakrd *AzureAksKubernetesRuntimeDefinition) GetType() string {
	return "AzureAksKubernetesRuntimeDefinition"
}

// Version returns the version of the API object.
func (aakrd *AzureAksKubernetesRuntimeDefinition) GetVersion() string {
	return "v0"
}

// NotificationPayload returns the notification payload that is delivered to the
// controller when a change is made.  It includes the object as presented by the
// client when the change was made.
func (aakri *AzureAksKubernetesRuntimeInstance) NotificationPayload(
	operation notifications.NotificationOperation,
	requeue bool,
	creationTime int64,
) (*[]byte, error) {
	notif := notifications.Notification{
		CreationTime:  &creationTime,
		Object:        aakri,
		ObjectVersion: aakri.GetVersion(),
		Operation:     operation,
	}

	payload, err := json.Marshal(notif)
	if err != nil {
		return &payload, fmt.Errorf("failed to marshal notification payload %+v: %w", aakri, err)
	}

	return &payload, nil
}

// DecodeNotifObject takes the threeport object in the form of a
// map[string]interface and returns the typed object by marshalling into JSON
// and then unmarshalling into the typed object.  We are not using the
// mapstructure library here as that requires custom decode hooks to manage
// fields with non-native go types.
func (aakri *AzureAksKubernetesRuntimeInstance) DecodeNotifObject(object interface{}) error {
	jsonObject, err := json.Marshal(object)
	if err != nil {
		return fmt.Errorf("failed to marshal object map from consumed notification message: %w", err)
	}
	if err := json.Unmarshal(jsonObject, &aakri); err != nil {
		return fmt.Errorf("failed to unmarshal json object to typed object: %w", err)
	}
	return nil
}

// GetId returns the unique ID for the object.
func (aakri *AzureAksKubernetesRuntimeInstance) GetId() uint {
	return *aakri.ID
}

// Type returns the object type.
func (aakri *AzureAksKubernetesRuntimeInstance) GetType() string {
	return "AzureAksKubernetesRuntimeInstance"
}

// Version returns the version of the API object.
func (aakri *AzureAksKubernetesRuntimeInstance) GetVersion() string {
	return "v0"
}

// ScheduledForDeletion returns a pointer to the DeletionScheduled timestamp
// if scheduled for deletion or nil if not scheduled for deletion.
func (aakri *AzureAksKubernetesRuntimeInstance) ScheduledForDeletion() *time.Time {
	return aakri.DeletionScheduled
}

// NotificationPayload returns the notification payload that is delivered to the
// controller when a change is made.  It includes the object as presented by the
// client when the change was made.
func (ardd *AzureRelationalDatabaseDefinition) NotificationPayload(
	operation notifications.NotificationOperation,
	requeue bool,
	creationTime int64,
) (*[]byte, error) {
	notif := notifications.Notification{
		CreationTime:  &creationTime,
		Object:        ardd,
		ObjectVersion: ardd.GetVersion(),
		Operation:     operation,
	}

	payload, err := json.Marshal(notif)
	if err != nil {
		return &payload, fmt.Errorf("failed to marshal notification payload %+v: %w", ardd, err)
	}

	return &payload, nil
}

// DecodeNotifObject takes the threeport object in the form of a
// map[string]interface and returns the typed object by marshalling into JSON
// and then unmarshalling into the typed object.  We are not using the
// mapstructure library here as that requires custom decode hooks to manage
// fields with non-native go types.
func (ardd *AzureRelationalDatabaseDefinition) DecodeNotifObject(object interface{}) error {
	jsonObject, err := json.Marshal(object)
	if err != nil {
		return fmt.Errorf("failed to marshal object map from consumed notification message: %w", err)
	}
	if err := json.Unmarshal(jsonObject, &ardd); err != nil {
		return fmt.Errorf("failed to unmarshal json object to typed object: %w", err)
	}
	return nil
}

// GetId returns the unique ID for the object.
func (ardd *AzureRelationalDatabaseDefinition) GetId() uint {
	return *ardd.ID
}

// Type returns the object type.
func (ardd *AzureRelationalDatabaseDefinition) GetType() string {
	return "AzureRelationalDatabaseDefinition"
}

// Version returns the version of the API object.
func (ardd *AzureRelationalDatabaseDefinition) GetVersion() string {
	return "v0"
}

// NotificationPayload returns the notification payload that is delivered to the
// controller when a change is made.  It includes the object as presented by the
// client when the change was made.
func (ardi *AzureRelationalDatabaseInstance) NotificationPayload(
	operation notifications.NotificationOperation,
	requeue bool,
	creationTime int64,
) (*[]byte, error) {
	notif := notifications.Notification{
		CreationTime:  &creationTime,
		Object:        ardi,
		ObjectVersion: ardi.GetVersion(),
		Operation:     operation,
	}

	payload, err := json.Marshal(notif)
	if err != nil {
		return &payload, fmt.Errorf("failed to marshal notification payload %+v: %w", ardi, err)
	}

	return &payload, nil
}

// DecodeNotifObject takes the threeport object in the form of a
// map[string]interface and returns the typed object by marshalling into JSON
// and then unmarshalling into the typed object.  We are not using the
// mapstructure library here as that requires custom decode hooks to manage
// fields with non-native go types.
func (ardi *AzureRelationalDatabaseInstance) DecodeNotifObject(object interface{}) error {
	jsonObject, err := json.Marshal(object)
	if err != nil {
		return fmt.Errorf("failed to marshal object map from consumed notification message: %w", err)
	}
	if err := json.Unmarshal(jsonObject, &ardi); err != nil {
		return fmt.Errorf("failed to unmarshal json object to typed object: %w", err)
	}
	return nil
}

// GetId returns the unique ID for the object.
func (ardi *AzureRelationalDatabaseInstance) GetId() uint {
	return *ardi.ID
}

// Type returns the object type.
func (ardi *AzureRelationalDatabaseInstance) GetType() string {
	return "AzureRelationalDatabaseInstance"
}

// Version returns the version of the API object.
func (ardi *AzureRelationalDatabaseInstance) GetVersion() string {
	return "v0"
}

// ScheduledForDeletion returns a pointer to the DeletionScheduled timestamp
// if scheduled for deletion or nil if not scheduled for deletion.
func (ardi *AzureRelationalDatabaseInstance) ScheduledForDeletion() *time.Time {
	return ardi.DeletionScheduled
}
