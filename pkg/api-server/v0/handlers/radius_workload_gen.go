// generated by 'threeport-codegen api-model' - do not edit

package handlers

import (
	"errors"
	"fmt"
	echo "github.com/labstack/echo/v4"
	api "github.com/threeport/threeport/pkg/api"
	iapi "github.com/threeport/threeport/pkg/api-server/v0"
	v0 "github.com/threeport/threeport/pkg/api/v0"
	notifications "github.com/threeport/threeport/pkg/notifications/v0"
	gorm "gorm.io/gorm"
	"net/http"
	"time"
)

///////////////////////////////////////////////////////////////////////////////
// RadiusWorkloadDefinition
///////////////////////////////////////////////////////////////////////////////

// @Summary GetRadiusWorkloadDefinitionVersions gets the supported versions for the radius workload definition API.
// @Description Get the supported API versions for radius workload definitions.
// @ID radiusWorkloadDefinition-get-versions
// @Produce json
// @Success 200 {object} api.RESTAPIVersions "OK"
// @Router /radius-workload-definitions/versions [GET]
func (h Handler) GetRadiusWorkloadDefinitionVersions(c echo.Context) error {
	return c.JSON(http.StatusOK, api.RestapiVersions[string(v0.ObjectTypeRadiusWorkloadDefinition)])
}

// @Summary adds a new radius workload definition.
// @Description Add a new radius workload definition to the Threeport database.
// @ID add-radiusWorkloadDefinition
// @Accept json
// @Produce json
// @Param radiusWorkloadDefinition body v0.RadiusWorkloadDefinition true "RadiusWorkloadDefinition object"
// @Success 201 {object} v0.Response "Created"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/radius-workload-definitions [POST]
func (h Handler) AddRadiusWorkloadDefinition(c echo.Context) error {
	objectType := v0.ObjectTypeRadiusWorkloadDefinition
	var radiusWorkloadDefinition v0.RadiusWorkloadDefinition

	// check for empty payload, unsupported fields, GORM Model fields, optional associations, etc.
	if id, err := iapi.PayloadCheck(c, false, objectType, radiusWorkloadDefinition); err != nil {
		return iapi.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	if err := c.Bind(&radiusWorkloadDefinition); err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := iapi.ValidateBoundData(c, radiusWorkloadDefinition, objectType); err != nil {
		return iapi.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// check for duplicate names
	var existingRadiusWorkloadDefinition v0.RadiusWorkloadDefinition
	nameUsed := true
	result := h.DB.Where("name = ?", radiusWorkloadDefinition.Name).First(&existingRadiusWorkloadDefinition)
	if result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			nameUsed = false
		} else {
			return iapi.ResponseStatus500(c, nil, result.Error, objectType)
		}
	}
	if nameUsed {
		return iapi.ResponseStatus409(c, nil, errors.New("object with provided name already exists"), objectType)
	}

	// persist to DB
	if result := h.DB.Create(&radiusWorkloadDefinition); result.Error != nil {
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// notify controller if reconciliation is required
	if !*radiusWorkloadDefinition.Reconciled {
		notifPayload, err := radiusWorkloadDefinition.NotificationPayload(
			notifications.NotificationOperationCreated,
			false,
			time.Now().Unix(),
		)
		if err != nil {
			return iapi.ResponseStatus500(c, nil, err, objectType)
		}
		h.JS.Publish(v0.RadiusWorkloadDefinitionCreateSubject, *notifPayload)
	}

	response, err := v0.CreateResponse(nil, radiusWorkloadDefinition, objectType)
	if err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	return iapi.ResponseStatus201(c, *response)
}

// @Summary gets all radius workload definitions.
// @Description Get all radius workload definitions from the Threeport database.
// @ID get-radiusWorkloadDefinitions
// @Accept json
// @Produce json
// @Param name query string false "radius workload definition search by name"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/radius-workload-definitions [GET]
func (h Handler) GetRadiusWorkloadDefinitions(c echo.Context) error {
	objectType := v0.ObjectTypeRadiusWorkloadDefinition
	params, err := c.(*iapi.CustomContext).GetPaginationParams()
	if err != nil {
		return iapi.ResponseStatus400(c, &params, err, objectType)
	}

	var filter v0.RadiusWorkloadDefinition
	if err := c.Bind(&filter); err != nil {
		return iapi.ResponseStatus500(c, &params, err, objectType)
	}

	var totalCount int64
	if result := h.DB.Model(&v0.RadiusWorkloadDefinition{}).Where(&filter).Count(&totalCount); result.Error != nil {
		return iapi.ResponseStatus500(c, &params, result.Error, objectType)
	}

	records := &[]v0.RadiusWorkloadDefinition{}
	if result := h.DB.Order("ID asc").Where(&filter).Limit(params.Size).Offset((params.Page - 1) * params.Size).Find(records); result.Error != nil {
		return iapi.ResponseStatus500(c, &params, result.Error, objectType)
	}

	response, err := v0.CreateResponse(v0.CreateMeta(params, totalCount), *records, objectType)
	if err != nil {
		return iapi.ResponseStatus500(c, &params, err, objectType)
	}

	return iapi.ResponseStatus200(c, *response)
}

// @Summary gets a radius workload definition.
// @Description Get a particular radius workload definition from the database.
// @ID get-radiusWorkloadDefinition
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/radius-workload-definitions/{id} [GET]
func (h Handler) GetRadiusWorkloadDefinition(c echo.Context) error {
	objectType := v0.ObjectTypeRadiusWorkloadDefinition
	radiusWorkloadDefinitionID := c.Param("id")
	var radiusWorkloadDefinition v0.RadiusWorkloadDefinition
	if result := h.DB.First(&radiusWorkloadDefinition, radiusWorkloadDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return iapi.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := v0.CreateResponse(nil, radiusWorkloadDefinition, objectType)
	if err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	return iapi.ResponseStatus200(c, *response)
}

// @Summary updates specific fields for an existing radius workload definition.
// @Description Update a radius workload definition in the database.  Provide one or more fields to update.
// @Description Note: This API endpint is for updating radius workload definition objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID update-radiusWorkloadDefinition
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param radiusWorkloadDefinition body v0.RadiusWorkloadDefinition true "RadiusWorkloadDefinition object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/radius-workload-definitions/{id} [PATCH]
func (h Handler) UpdateRadiusWorkloadDefinition(c echo.Context) error {
	objectType := v0.ObjectTypeRadiusWorkloadDefinition
	radiusWorkloadDefinitionID := c.Param("id")
	var existingRadiusWorkloadDefinition v0.RadiusWorkloadDefinition
	if result := h.DB.First(&existingRadiusWorkloadDefinition, radiusWorkloadDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return iapi.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := iapi.PayloadCheck(c, true, objectType, existingRadiusWorkloadDefinition); err != nil {
		return iapi.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedRadiusWorkloadDefinition v0.RadiusWorkloadDefinition
	if err := c.Bind(&updatedRadiusWorkloadDefinition); err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	// update object in database
	if result := h.DB.Model(&existingRadiusWorkloadDefinition).Updates(updatedRadiusWorkloadDefinition); result.Error != nil {
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// notify controller if reconciliation is required
	if !*existingRadiusWorkloadDefinition.Reconciled {
		notifPayload, err := existingRadiusWorkloadDefinition.NotificationPayload(
			notifications.NotificationOperationUpdated,
			false,
			time.Now().Unix(),
		)
		if err != nil {
			return iapi.ResponseStatus500(c, nil, err, objectType)
		}
		h.JS.Publish(v0.RadiusWorkloadDefinitionUpdateSubject, *notifPayload)
	}

	response, err := v0.CreateResponse(nil, existingRadiusWorkloadDefinition, objectType)
	if err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	return iapi.ResponseStatus200(c, *response)
}

// @Summary updates an existing radius workload definition by replacing the entire object.
// @Description Replace a radius workload definition in the database.  All required fields must be provided.
// @Description If any optional fields are not provided, they will be null post-update.
// @Description Note: This API endpint is for updating radius workload definition objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID replace-radiusWorkloadDefinition
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param radiusWorkloadDefinition body v0.RadiusWorkloadDefinition true "RadiusWorkloadDefinition object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/radius-workload-definitions/{id} [PUT]
func (h Handler) ReplaceRadiusWorkloadDefinition(c echo.Context) error {
	objectType := v0.ObjectTypeRadiusWorkloadDefinition
	radiusWorkloadDefinitionID := c.Param("id")
	var existingRadiusWorkloadDefinition v0.RadiusWorkloadDefinition
	if result := h.DB.First(&existingRadiusWorkloadDefinition, radiusWorkloadDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return iapi.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := iapi.PayloadCheck(c, true, objectType, existingRadiusWorkloadDefinition); err != nil {
		return iapi.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedRadiusWorkloadDefinition v0.RadiusWorkloadDefinition
	if err := c.Bind(&updatedRadiusWorkloadDefinition); err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := iapi.ValidateBoundData(c, updatedRadiusWorkloadDefinition, objectType); err != nil {
		return iapi.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// persist provided data
	updatedRadiusWorkloadDefinition.ID = existingRadiusWorkloadDefinition.ID
	if result := h.DB.Session(&gorm.Session{FullSaveAssociations: false}).Omit("CreatedAt", "DeletedAt").Save(&updatedRadiusWorkloadDefinition); result.Error != nil {
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// reload updated data from DB
	if result := h.DB.First(&existingRadiusWorkloadDefinition, radiusWorkloadDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return iapi.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := v0.CreateResponse(nil, existingRadiusWorkloadDefinition, objectType)
	if err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	return iapi.ResponseStatus200(c, *response)
}

// @Summary deletes a radius workload definition.
// @Description Delete a radius workload definition by ID from the database.
// @ID delete-radiusWorkloadDefinition
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 409 {object} v0.Response "Conflict"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/radius-workload-definitions/{id} [DELETE]
func (h Handler) DeleteRadiusWorkloadDefinition(c echo.Context) error {
	objectType := v0.ObjectTypeRadiusWorkloadDefinition
	radiusWorkloadDefinitionID := c.Param("id")
	var radiusWorkloadDefinition v0.RadiusWorkloadDefinition
	if result := h.DB.First(&radiusWorkloadDefinition, radiusWorkloadDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return iapi.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// schedule for deletion if not already scheduled
	// if scheduled and reconciled, delete object from DB
	// if scheduled but not reconciled, return 409 (controller is working on it)
	if radiusWorkloadDefinition.DeletionScheduled == nil {
		// schedule for deletion
		reconciled := false
		timestamp := time.Now().UTC()
		scheduledRadiusWorkloadDefinition := v0.RadiusWorkloadDefinition{
			Reconciliation: v0.Reconciliation{
				DeletionScheduled: &timestamp,
				Reconciled:        &reconciled,
			}}
		if result := h.DB.Model(&radiusWorkloadDefinition).Updates(scheduledRadiusWorkloadDefinition); result.Error != nil {
			return iapi.ResponseStatus500(c, nil, result.Error, objectType)
		}
		// notify controller
		notifPayload, err := radiusWorkloadDefinition.NotificationPayload(
			notifications.NotificationOperationDeleted,
			false,
			time.Now().Unix(),
		)
		if err != nil {
			return iapi.ResponseStatus500(c, nil, err, objectType)
		}
		h.JS.Publish(v0.RadiusWorkloadDefinitionDeleteSubject, *notifPayload)
	} else {
		if radiusWorkloadDefinition.DeletionConfirmed == nil {
			// if deletion scheduled but not reconciled, return 409 - deletion
			// already underway
			return iapi.ResponseStatus409(c, nil, errors.New(fmt.Sprintf(
				"object with ID %d already being deleted",
				*radiusWorkloadDefinition.ID,
			)), objectType)
		} else {
			// object scheduled for deletion and confirmed - it can be deleted
			// from DB
			if result := h.DB.Delete(&radiusWorkloadDefinition); result.Error != nil {
				return iapi.ResponseStatus500(c, nil, result.Error, objectType)
			}
		}
	}

	response, err := v0.CreateResponse(nil, radiusWorkloadDefinition, objectType)
	if err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	return iapi.ResponseStatus200(c, *response)
}

///////////////////////////////////////////////////////////////////////////////
// RadiusWorkloadInstance
///////////////////////////////////////////////////////////////////////////////

// @Summary GetRadiusWorkloadInstanceVersions gets the supported versions for the radius workload instance API.
// @Description Get the supported API versions for radius workload instances.
// @ID radiusWorkloadInstance-get-versions
// @Produce json
// @Success 200 {object} api.RESTAPIVersions "OK"
// @Router /radius-workload-instances/versions [GET]
func (h Handler) GetRadiusWorkloadInstanceVersions(c echo.Context) error {
	return c.JSON(http.StatusOK, api.RestapiVersions[string(v0.ObjectTypeRadiusWorkloadInstance)])
}

// @Summary adds a new radius workload instance.
// @Description Add a new radius workload instance to the Threeport database.
// @ID add-radiusWorkloadInstance
// @Accept json
// @Produce json
// @Param radiusWorkloadInstance body v0.RadiusWorkloadInstance true "RadiusWorkloadInstance object"
// @Success 201 {object} v0.Response "Created"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/radius-workload-instances [POST]
func (h Handler) AddRadiusWorkloadInstance(c echo.Context) error {
	objectType := v0.ObjectTypeRadiusWorkloadInstance
	var radiusWorkloadInstance v0.RadiusWorkloadInstance

	// check for empty payload, unsupported fields, GORM Model fields, optional associations, etc.
	if id, err := iapi.PayloadCheck(c, false, objectType, radiusWorkloadInstance); err != nil {
		return iapi.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	if err := c.Bind(&radiusWorkloadInstance); err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := iapi.ValidateBoundData(c, radiusWorkloadInstance, objectType); err != nil {
		return iapi.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// check for duplicate names
	var existingRadiusWorkloadInstance v0.RadiusWorkloadInstance
	nameUsed := true
	result := h.DB.Where("name = ?", radiusWorkloadInstance.Name).First(&existingRadiusWorkloadInstance)
	if result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			nameUsed = false
		} else {
			return iapi.ResponseStatus500(c, nil, result.Error, objectType)
		}
	}
	if nameUsed {
		return iapi.ResponseStatus409(c, nil, errors.New("object with provided name already exists"), objectType)
	}

	// persist to DB
	if result := h.DB.Create(&radiusWorkloadInstance); result.Error != nil {
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// notify controller if reconciliation is required
	if !*radiusWorkloadInstance.Reconciled {
		notifPayload, err := radiusWorkloadInstance.NotificationPayload(
			notifications.NotificationOperationCreated,
			false,
			time.Now().Unix(),
		)
		if err != nil {
			return iapi.ResponseStatus500(c, nil, err, objectType)
		}
		h.JS.Publish(v0.RadiusWorkloadInstanceCreateSubject, *notifPayload)
	}

	response, err := v0.CreateResponse(nil, radiusWorkloadInstance, objectType)
	if err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	return iapi.ResponseStatus201(c, *response)
}

// @Summary gets all radius workload instances.
// @Description Get all radius workload instances from the Threeport database.
// @ID get-radiusWorkloadInstances
// @Accept json
// @Produce json
// @Param name query string false "radius workload instance search by name"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/radius-workload-instances [GET]
func (h Handler) GetRadiusWorkloadInstances(c echo.Context) error {
	objectType := v0.ObjectTypeRadiusWorkloadInstance
	params, err := c.(*iapi.CustomContext).GetPaginationParams()
	if err != nil {
		return iapi.ResponseStatus400(c, &params, err, objectType)
	}

	var filter v0.RadiusWorkloadInstance
	if err := c.Bind(&filter); err != nil {
		return iapi.ResponseStatus500(c, &params, err, objectType)
	}

	var totalCount int64
	if result := h.DB.Model(&v0.RadiusWorkloadInstance{}).Where(&filter).Count(&totalCount); result.Error != nil {
		return iapi.ResponseStatus500(c, &params, result.Error, objectType)
	}

	records := &[]v0.RadiusWorkloadInstance{}
	if result := h.DB.Order("ID asc").Where(&filter).Limit(params.Size).Offset((params.Page - 1) * params.Size).Find(records); result.Error != nil {
		return iapi.ResponseStatus500(c, &params, result.Error, objectType)
	}

	response, err := v0.CreateResponse(v0.CreateMeta(params, totalCount), *records, objectType)
	if err != nil {
		return iapi.ResponseStatus500(c, &params, err, objectType)
	}

	return iapi.ResponseStatus200(c, *response)
}

// @Summary gets a radius workload instance.
// @Description Get a particular radius workload instance from the database.
// @ID get-radiusWorkloadInstance
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/radius-workload-instances/{id} [GET]
func (h Handler) GetRadiusWorkloadInstance(c echo.Context) error {
	objectType := v0.ObjectTypeRadiusWorkloadInstance
	radiusWorkloadInstanceID := c.Param("id")
	var radiusWorkloadInstance v0.RadiusWorkloadInstance
	if result := h.DB.First(&radiusWorkloadInstance, radiusWorkloadInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return iapi.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := v0.CreateResponse(nil, radiusWorkloadInstance, objectType)
	if err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	return iapi.ResponseStatus200(c, *response)
}

// @Summary updates specific fields for an existing radius workload instance.
// @Description Update a radius workload instance in the database.  Provide one or more fields to update.
// @Description Note: This API endpint is for updating radius workload instance objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID update-radiusWorkloadInstance
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param radiusWorkloadInstance body v0.RadiusWorkloadInstance true "RadiusWorkloadInstance object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/radius-workload-instances/{id} [PATCH]
func (h Handler) UpdateRadiusWorkloadInstance(c echo.Context) error {
	objectType := v0.ObjectTypeRadiusWorkloadInstance
	radiusWorkloadInstanceID := c.Param("id")
	var existingRadiusWorkloadInstance v0.RadiusWorkloadInstance
	if result := h.DB.First(&existingRadiusWorkloadInstance, radiusWorkloadInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return iapi.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := iapi.PayloadCheck(c, true, objectType, existingRadiusWorkloadInstance); err != nil {
		return iapi.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedRadiusWorkloadInstance v0.RadiusWorkloadInstance
	if err := c.Bind(&updatedRadiusWorkloadInstance); err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	// update object in database
	if result := h.DB.Model(&existingRadiusWorkloadInstance).Updates(updatedRadiusWorkloadInstance); result.Error != nil {
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// notify controller if reconciliation is required
	if !*existingRadiusWorkloadInstance.Reconciled {
		notifPayload, err := existingRadiusWorkloadInstance.NotificationPayload(
			notifications.NotificationOperationUpdated,
			false,
			time.Now().Unix(),
		)
		if err != nil {
			return iapi.ResponseStatus500(c, nil, err, objectType)
		}
		h.JS.Publish(v0.RadiusWorkloadInstanceUpdateSubject, *notifPayload)
	}

	response, err := v0.CreateResponse(nil, existingRadiusWorkloadInstance, objectType)
	if err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	return iapi.ResponseStatus200(c, *response)
}

// @Summary updates an existing radius workload instance by replacing the entire object.
// @Description Replace a radius workload instance in the database.  All required fields must be provided.
// @Description If any optional fields are not provided, they will be null post-update.
// @Description Note: This API endpint is for updating radius workload instance objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID replace-radiusWorkloadInstance
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param radiusWorkloadInstance body v0.RadiusWorkloadInstance true "RadiusWorkloadInstance object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/radius-workload-instances/{id} [PUT]
func (h Handler) ReplaceRadiusWorkloadInstance(c echo.Context) error {
	objectType := v0.ObjectTypeRadiusWorkloadInstance
	radiusWorkloadInstanceID := c.Param("id")
	var existingRadiusWorkloadInstance v0.RadiusWorkloadInstance
	if result := h.DB.First(&existingRadiusWorkloadInstance, radiusWorkloadInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return iapi.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := iapi.PayloadCheck(c, true, objectType, existingRadiusWorkloadInstance); err != nil {
		return iapi.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedRadiusWorkloadInstance v0.RadiusWorkloadInstance
	if err := c.Bind(&updatedRadiusWorkloadInstance); err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := iapi.ValidateBoundData(c, updatedRadiusWorkloadInstance, objectType); err != nil {
		return iapi.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// persist provided data
	updatedRadiusWorkloadInstance.ID = existingRadiusWorkloadInstance.ID
	if result := h.DB.Session(&gorm.Session{FullSaveAssociations: false}).Omit("CreatedAt", "DeletedAt").Save(&updatedRadiusWorkloadInstance); result.Error != nil {
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// reload updated data from DB
	if result := h.DB.First(&existingRadiusWorkloadInstance, radiusWorkloadInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return iapi.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := v0.CreateResponse(nil, existingRadiusWorkloadInstance, objectType)
	if err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	return iapi.ResponseStatus200(c, *response)
}

// @Summary deletes a radius workload instance.
// @Description Delete a radius workload instance by ID from the database.
// @ID delete-radiusWorkloadInstance
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 409 {object} v0.Response "Conflict"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/radius-workload-instances/{id} [DELETE]
func (h Handler) DeleteRadiusWorkloadInstance(c echo.Context) error {
	objectType := v0.ObjectTypeRadiusWorkloadInstance
	radiusWorkloadInstanceID := c.Param("id")
	var radiusWorkloadInstance v0.RadiusWorkloadInstance
	if result := h.DB.First(&radiusWorkloadInstance, radiusWorkloadInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return iapi.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return iapi.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// schedule for deletion if not already scheduled
	// if scheduled and reconciled, delete object from DB
	// if scheduled but not reconciled, return 409 (controller is working on it)
	if radiusWorkloadInstance.DeletionScheduled == nil {
		// schedule for deletion
		reconciled := false
		timestamp := time.Now().UTC()
		scheduledRadiusWorkloadInstance := v0.RadiusWorkloadInstance{
			Reconciliation: v0.Reconciliation{
				DeletionScheduled: &timestamp,
				Reconciled:        &reconciled,
			}}
		if result := h.DB.Model(&radiusWorkloadInstance).Updates(scheduledRadiusWorkloadInstance); result.Error != nil {
			return iapi.ResponseStatus500(c, nil, result.Error, objectType)
		}
		// notify controller
		notifPayload, err := radiusWorkloadInstance.NotificationPayload(
			notifications.NotificationOperationDeleted,
			false,
			time.Now().Unix(),
		)
		if err != nil {
			return iapi.ResponseStatus500(c, nil, err, objectType)
		}
		h.JS.Publish(v0.RadiusWorkloadInstanceDeleteSubject, *notifPayload)
	} else {
		if radiusWorkloadInstance.DeletionConfirmed == nil {
			// if deletion scheduled but not reconciled, return 409 - deletion
			// already underway
			return iapi.ResponseStatus409(c, nil, errors.New(fmt.Sprintf(
				"object with ID %d already being deleted",
				*radiusWorkloadInstance.ID,
			)), objectType)
		} else {
			// object scheduled for deletion and confirmed - it can be deleted
			// from DB
			if result := h.DB.Delete(&radiusWorkloadInstance); result.Error != nil {
				return iapi.ResponseStatus500(c, nil, result.Error, objectType)
			}
		}
	}

	response, err := v0.CreateResponse(nil, radiusWorkloadInstance, objectType)
	if err != nil {
		return iapi.ResponseStatus500(c, nil, err, objectType)
	}

	return iapi.ResponseStatus200(c, *response)
}
