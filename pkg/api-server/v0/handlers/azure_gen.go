// generated by 'threeport-sdk gen' - do not edit

package handlers

import (
	"errors"
	"fmt"
	echo "github.com/labstack/echo/v4"
	notif "github.com/threeport/threeport/internal/azure/notif"
	apiserver_lib "github.com/threeport/threeport/pkg/api-server/lib/v0"
	api_v0 "github.com/threeport/threeport/pkg/api/v0"
	notifications "github.com/threeport/threeport/pkg/notifications/v0"
	gorm "gorm.io/gorm"
	"net/http"
	"time"
)

///////////////////////////////////////////////////////////////////////////////
// AzureAccount
///////////////////////////////////////////////////////////////////////////////

// @Summary GetAzureAccountVersions gets the supported versions for the azure account API.
// @Description Get the supported API versions for azure accounts.
// @ID azureAccount-get-versions
// @Produce json
// @Success 200 {object} apiserver_lib.ApiObjectVersions "OK"
// @Router /azure-accounts/versions [GET]
func (h Handler) GetAzureAccountVersions(c echo.Context) error {
	return c.JSON(http.StatusOK, apiserver_lib.ObjectVersions[string(api_v0.ObjectTypeAzureAccount)])
}

// @Summary adds a new azure account.
// @Description Add a new azure account to the Threeport database.
// @ID add-v0-azureAccount
// @Accept json
// @Produce json
// @Param azureAccount body api_v0.AzureAccount true "AzureAccount object"
// @Success 201 {object} v0.Response "Created"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/azure-accounts [POST]
func (h Handler) AddAzureAccount(c echo.Context) error {
	objectType := api_v0.ObjectTypeAzureAccount
	var azureAccount api_v0.AzureAccount

	// check for empty payload, unsupported fields, GORM Model fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, false, objectType, azureAccount); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	if err := c.Bind(&azureAccount); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := apiserver_lib.ValidateBoundData(c, azureAccount, objectType); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// check for duplicate names
	var existingAzureAccount api_v0.AzureAccount
	nameUsed := true
	result := h.DB.Where("name = ?", azureAccount.Name).First(&existingAzureAccount)
	if result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			nameUsed = false
		} else {
			return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
		}
	}
	if nameUsed {
		return apiserver_lib.ResponseStatus409(c, nil, errors.New("object with provided name already exists"), objectType)
	}

	// persist to DB
	if result := h.DB.Create(&azureAccount); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, azureAccount, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus201(c, *response)
}

// @Summary gets all azure accounts.
// @Description Get all azure accounts from the Threeport database.
// @ID get-v0-azureAccounts
// @Accept json
// @Produce json
// @Param name query string false "azure account search by name"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/azure-accounts [GET]
func (h Handler) GetAzureAccounts(c echo.Context) error {
	objectType := api_v0.ObjectTypeAzureAccount
	params, err := c.(*apiserver_lib.CustomContext).GetPaginationParams()
	if err != nil {
		return apiserver_lib.ResponseStatus400(c, &params, err, objectType)
	}

	var filter api_v0.AzureAccount
	if err := c.Bind(&filter); err != nil {
		return apiserver_lib.ResponseStatus500(c, &params, err, objectType)
	}

	var totalCount int64
	if result := h.DB.Model(&api_v0.AzureAccount{}).Where(&filter).Count(&totalCount); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, &params, result.Error, objectType)
	}

	records := &[]api_v0.AzureAccount{}
	if result := h.DB.Order("ID asc").Where(&filter).Limit(params.Size).Offset((params.Page - 1) * params.Size).Find(records); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, &params, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(apiserver_lib.CreateMeta(params, totalCount), *records, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, &params, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary gets a azure account.
// @Description Get a particular azure account from the database.
// @ID get-v0-azureAccount
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/azure-accounts/{id} [GET]
func (h Handler) GetAzureAccount(c echo.Context) error {
	objectType := api_v0.ObjectTypeAzureAccount
	azureAccountID := c.Param("id")
	var azureAccount api_v0.AzureAccount
	if result := h.DB.First(&azureAccount, azureAccountID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, azureAccount, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary updates specific fields for an existing azure account.
// @Description Update a azure account in the database.  Provide one or more fields to update.
// @Description Note: This API endpint is for updating azure account objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID update-v0-azureAccount
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param azureAccount body api_v0.AzureAccount true "AzureAccount object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/azure-accounts/{id} [PATCH]
func (h Handler) UpdateAzureAccount(c echo.Context) error {
	objectType := api_v0.ObjectTypeAzureAccount
	azureAccountID := c.Param("id")
	var existingAzureAccount api_v0.AzureAccount
	if result := h.DB.First(&existingAzureAccount, azureAccountID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, true, objectType, existingAzureAccount); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedAzureAccount api_v0.AzureAccount
	if err := c.Bind(&updatedAzureAccount); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// update object in database
	if result := h.DB.Model(&existingAzureAccount).Updates(updatedAzureAccount); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, existingAzureAccount, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary updates an existing azure account by replacing the entire object.
// @Description Replace a azure account in the database.  All required fields must be provided.
// @Description If any optional fields are not provided, they will be null post-update.
// @Description Note: This API endpint is for updating azure account objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID replace-v0-azureAccount
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param azureAccount body api_v0.AzureAccount true "AzureAccount object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/azure-accounts/{id} [PUT]
func (h Handler) ReplaceAzureAccount(c echo.Context) error {
	objectType := api_v0.ObjectTypeAzureAccount
	azureAccountID := c.Param("id")
	var existingAzureAccount api_v0.AzureAccount
	if result := h.DB.First(&existingAzureAccount, azureAccountID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, true, objectType, existingAzureAccount); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedAzureAccount api_v0.AzureAccount
	if err := c.Bind(&updatedAzureAccount); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := apiserver_lib.ValidateBoundData(c, updatedAzureAccount, objectType); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// persist provided data
	updatedAzureAccount.ID = existingAzureAccount.ID
	if result := h.DB.Session(&gorm.Session{FullSaveAssociations: false}).Omit("CreatedAt", "DeletedAt").Save(&updatedAzureAccount); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// reload updated data from DB
	if result := h.DB.First(&existingAzureAccount, azureAccountID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, existingAzureAccount, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary deletes a azure account.
// @Description Delete a azure account by ID from the database.
// @ID delete-v0-azureAccount
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 409 {object} v0.Response "Conflict"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/azure-accounts/{id} [DELETE]
func (h Handler) DeleteAzureAccount(c echo.Context) error {
	objectType := api_v0.ObjectTypeAzureAccount
	azureAccountID := c.Param("id")
	var azureAccount api_v0.AzureAccount
	if result := h.DB.First(&azureAccount, azureAccountID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// delete object
	if result := h.DB.Delete(&azureAccount); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, azureAccount, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

///////////////////////////////////////////////////////////////////////////////
// AzureAksKubernetesRuntimeDefinition
///////////////////////////////////////////////////////////////////////////////

// @Summary GetAzureAksKubernetesRuntimeDefinitionVersions gets the supported versions for the azure aks kubernetes runtime definition API.
// @Description Get the supported API versions for azure aks kubernetes runtime definitions.
// @ID azureAksKubernetesRuntimeDefinition-get-versions
// @Produce json
// @Success 200 {object} apiserver_lib.ApiObjectVersions "OK"
// @Router /azure-aks-kubernetes-runtime-definitions/versions [GET]
func (h Handler) GetAzureAksKubernetesRuntimeDefinitionVersions(c echo.Context) error {
	return c.JSON(http.StatusOK, apiserver_lib.ObjectVersions[string(api_v0.ObjectTypeAzureAksKubernetesRuntimeDefinition)])
}

// @Summary adds a new azure aks kubernetes runtime definition.
// @Description Add a new azure aks kubernetes runtime definition to the Threeport database.
// @ID add-v0-azureAksKubernetesRuntimeDefinition
// @Accept json
// @Produce json
// @Param azureAksKubernetesRuntimeDefinition body api_v0.AzureAksKubernetesRuntimeDefinition true "AzureAksKubernetesRuntimeDefinition object"
// @Success 201 {object} v0.Response "Created"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/azure-aks-kubernetes-runtime-definitions [POST]
func (h Handler) AddAzureAksKubernetesRuntimeDefinition(c echo.Context) error {
	objectType := api_v0.ObjectTypeAzureAksKubernetesRuntimeDefinition
	var azureAksKubernetesRuntimeDefinition api_v0.AzureAksKubernetesRuntimeDefinition

	// check for empty payload, unsupported fields, GORM Model fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, false, objectType, azureAksKubernetesRuntimeDefinition); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	if err := c.Bind(&azureAksKubernetesRuntimeDefinition); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := apiserver_lib.ValidateBoundData(c, azureAksKubernetesRuntimeDefinition, objectType); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// check for duplicate names
	var existingAzureAksKubernetesRuntimeDefinition api_v0.AzureAksKubernetesRuntimeDefinition
	nameUsed := true
	result := h.DB.Where("name = ?", azureAksKubernetesRuntimeDefinition.Name).First(&existingAzureAksKubernetesRuntimeDefinition)
	if result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			nameUsed = false
		} else {
			return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
		}
	}
	if nameUsed {
		return apiserver_lib.ResponseStatus409(c, nil, errors.New("object with provided name already exists"), objectType)
	}

	// persist to DB
	if result := h.DB.Create(&azureAksKubernetesRuntimeDefinition); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, azureAksKubernetesRuntimeDefinition, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus201(c, *response)
}

// @Summary gets all azure aks kubernetes runtime definitions.
// @Description Get all azure aks kubernetes runtime definitions from the Threeport database.
// @ID get-v0-azureAksKubernetesRuntimeDefinitions
// @Accept json
// @Produce json
// @Param name query string false "azure aks kubernetes runtime definition search by name"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/azure-aks-kubernetes-runtime-definitions [GET]
func (h Handler) GetAzureAksKubernetesRuntimeDefinitions(c echo.Context) error {
	objectType := api_v0.ObjectTypeAzureAksKubernetesRuntimeDefinition
	params, err := c.(*apiserver_lib.CustomContext).GetPaginationParams()
	if err != nil {
		return apiserver_lib.ResponseStatus400(c, &params, err, objectType)
	}

	var filter api_v0.AzureAksKubernetesRuntimeDefinition
	if err := c.Bind(&filter); err != nil {
		return apiserver_lib.ResponseStatus500(c, &params, err, objectType)
	}

	var totalCount int64
	if result := h.DB.Model(&api_v0.AzureAksKubernetesRuntimeDefinition{}).Where(&filter).Count(&totalCount); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, &params, result.Error, objectType)
	}

	records := &[]api_v0.AzureAksKubernetesRuntimeDefinition{}
	if result := h.DB.Order("ID asc").Where(&filter).Limit(params.Size).Offset((params.Page - 1) * params.Size).Find(records); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, &params, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(apiserver_lib.CreateMeta(params, totalCount), *records, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, &params, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary gets a azure aks kubernetes runtime definition.
// @Description Get a particular azure aks kubernetes runtime definition from the database.
// @ID get-v0-azureAksKubernetesRuntimeDefinition
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/azure-aks-kubernetes-runtime-definitions/{id} [GET]
func (h Handler) GetAzureAksKubernetesRuntimeDefinition(c echo.Context) error {
	objectType := api_v0.ObjectTypeAzureAksKubernetesRuntimeDefinition
	azureAksKubernetesRuntimeDefinitionID := c.Param("id")
	var azureAksKubernetesRuntimeDefinition api_v0.AzureAksKubernetesRuntimeDefinition
	if result := h.DB.First(&azureAksKubernetesRuntimeDefinition, azureAksKubernetesRuntimeDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, azureAksKubernetesRuntimeDefinition, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary updates specific fields for an existing azure aks kubernetes runtime definition.
// @Description Update a azure aks kubernetes runtime definition in the database.  Provide one or more fields to update.
// @Description Note: This API endpint is for updating azure aks kubernetes runtime definition objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID update-v0-azureAksKubernetesRuntimeDefinition
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param azureAksKubernetesRuntimeDefinition body api_v0.AzureAksKubernetesRuntimeDefinition true "AzureAksKubernetesRuntimeDefinition object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/azure-aks-kubernetes-runtime-definitions/{id} [PATCH]
func (h Handler) UpdateAzureAksKubernetesRuntimeDefinition(c echo.Context) error {
	objectType := api_v0.ObjectTypeAzureAksKubernetesRuntimeDefinition
	azureAksKubernetesRuntimeDefinitionID := c.Param("id")
	var existingAzureAksKubernetesRuntimeDefinition api_v0.AzureAksKubernetesRuntimeDefinition
	if result := h.DB.First(&existingAzureAksKubernetesRuntimeDefinition, azureAksKubernetesRuntimeDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, true, objectType, existingAzureAksKubernetesRuntimeDefinition); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedAzureAksKubernetesRuntimeDefinition api_v0.AzureAksKubernetesRuntimeDefinition
	if err := c.Bind(&updatedAzureAksKubernetesRuntimeDefinition); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// update object in database
	if result := h.DB.Model(&existingAzureAksKubernetesRuntimeDefinition).Updates(updatedAzureAksKubernetesRuntimeDefinition); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, existingAzureAksKubernetesRuntimeDefinition, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary updates an existing azure aks kubernetes runtime definition by replacing the entire object.
// @Description Replace a azure aks kubernetes runtime definition in the database.  All required fields must be provided.
// @Description If any optional fields are not provided, they will be null post-update.
// @Description Note: This API endpint is for updating azure aks kubernetes runtime definition objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID replace-v0-azureAksKubernetesRuntimeDefinition
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param azureAksKubernetesRuntimeDefinition body api_v0.AzureAksKubernetesRuntimeDefinition true "AzureAksKubernetesRuntimeDefinition object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/azure-aks-kubernetes-runtime-definitions/{id} [PUT]
func (h Handler) ReplaceAzureAksKubernetesRuntimeDefinition(c echo.Context) error {
	objectType := api_v0.ObjectTypeAzureAksKubernetesRuntimeDefinition
	azureAksKubernetesRuntimeDefinitionID := c.Param("id")
	var existingAzureAksKubernetesRuntimeDefinition api_v0.AzureAksKubernetesRuntimeDefinition
	if result := h.DB.First(&existingAzureAksKubernetesRuntimeDefinition, azureAksKubernetesRuntimeDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, true, objectType, existingAzureAksKubernetesRuntimeDefinition); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedAzureAksKubernetesRuntimeDefinition api_v0.AzureAksKubernetesRuntimeDefinition
	if err := c.Bind(&updatedAzureAksKubernetesRuntimeDefinition); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := apiserver_lib.ValidateBoundData(c, updatedAzureAksKubernetesRuntimeDefinition, objectType); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// persist provided data
	updatedAzureAksKubernetesRuntimeDefinition.ID = existingAzureAksKubernetesRuntimeDefinition.ID
	if result := h.DB.Session(&gorm.Session{FullSaveAssociations: false}).Omit("CreatedAt", "DeletedAt").Save(&updatedAzureAksKubernetesRuntimeDefinition); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// reload updated data from DB
	if result := h.DB.First(&existingAzureAksKubernetesRuntimeDefinition, azureAksKubernetesRuntimeDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, existingAzureAksKubernetesRuntimeDefinition, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary deletes a azure aks kubernetes runtime definition.
// @Description Delete a azure aks kubernetes runtime definition by ID from the database.
// @ID delete-v0-azureAksKubernetesRuntimeDefinition
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 409 {object} v0.Response "Conflict"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/azure-aks-kubernetes-runtime-definitions/{id} [DELETE]
func (h Handler) DeleteAzureAksKubernetesRuntimeDefinition(c echo.Context) error {
	objectType := api_v0.ObjectTypeAzureAksKubernetesRuntimeDefinition
	azureAksKubernetesRuntimeDefinitionID := c.Param("id")
	var azureAksKubernetesRuntimeDefinition api_v0.AzureAksKubernetesRuntimeDefinition
	if result := h.DB.Preload("AzureAksKubernetesRuntimeInstances").First(&azureAksKubernetesRuntimeDefinition, azureAksKubernetesRuntimeDefinitionID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check to make sure no dependent instances exist for this definition
	if len(azureAksKubernetesRuntimeDefinition.AzureAksKubernetesRuntimeInstances) != 0 {
		err := errors.New("azure aks kubernetes runtime definition has related azure aks kubernetes runtime instances - cannot be deleted")
		return apiserver_lib.ResponseStatus409(c, nil, err, objectType)
	}

	// delete object
	if result := h.DB.Delete(&azureAksKubernetesRuntimeDefinition); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, azureAksKubernetesRuntimeDefinition, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

///////////////////////////////////////////////////////////////////////////////
// AzureAksKubernetesRuntimeInstance
///////////////////////////////////////////////////////////////////////////////

// @Summary GetAzureAksKubernetesRuntimeInstanceVersions gets the supported versions for the azure aks kubernetes runtime instance API.
// @Description Get the supported API versions for azure aks kubernetes runtime instances.
// @ID azureAksKubernetesRuntimeInstance-get-versions
// @Produce json
// @Success 200 {object} apiserver_lib.ApiObjectVersions "OK"
// @Router /azure-aks-kubernetes-runtime-instances/versions [GET]
func (h Handler) GetAzureAksKubernetesRuntimeInstanceVersions(c echo.Context) error {
	return c.JSON(http.StatusOK, apiserver_lib.ObjectVersions[string(api_v0.ObjectTypeAzureAksKubernetesRuntimeInstance)])
}

// @Summary adds a new azure aks kubernetes runtime instance.
// @Description Add a new azure aks kubernetes runtime instance to the Threeport database.
// @ID add-v0-azureAksKubernetesRuntimeInstance
// @Accept json
// @Produce json
// @Param azureAksKubernetesRuntimeInstance body api_v0.AzureAksKubernetesRuntimeInstance true "AzureAksKubernetesRuntimeInstance object"
// @Success 201 {object} v0.Response "Created"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/azure-aks-kubernetes-runtime-instances [POST]
func (h Handler) AddAzureAksKubernetesRuntimeInstance(c echo.Context) error {
	objectType := api_v0.ObjectTypeAzureAksKubernetesRuntimeInstance
	var azureAksKubernetesRuntimeInstance api_v0.AzureAksKubernetesRuntimeInstance

	// check for empty payload, unsupported fields, GORM Model fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, false, objectType, azureAksKubernetesRuntimeInstance); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	if err := c.Bind(&azureAksKubernetesRuntimeInstance); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := apiserver_lib.ValidateBoundData(c, azureAksKubernetesRuntimeInstance, objectType); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// check for duplicate names
	var existingAzureAksKubernetesRuntimeInstance api_v0.AzureAksKubernetesRuntimeInstance
	nameUsed := true
	result := h.DB.Where("name = ?", azureAksKubernetesRuntimeInstance.Name).First(&existingAzureAksKubernetesRuntimeInstance)
	if result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			nameUsed = false
		} else {
			return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
		}
	}
	if nameUsed {
		return apiserver_lib.ResponseStatus409(c, nil, errors.New("object with provided name already exists"), objectType)
	}

	// persist to DB
	if result := h.DB.Create(&azureAksKubernetesRuntimeInstance); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// notify controller if reconciliation is required
	if !*azureAksKubernetesRuntimeInstance.Reconciled {
		notifPayload, err := azureAksKubernetesRuntimeInstance.NotificationPayload(
			notifications.NotificationOperationCreated,
			false,
			time.Now().Unix(),
		)
		if err != nil {
			return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
		}
		h.JS.Publish(notif.AzureAksKubernetesRuntimeInstanceCreateSubject, *notifPayload)
	}

	response, err := apiserver_lib.CreateResponse(nil, azureAksKubernetesRuntimeInstance, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus201(c, *response)
}

// @Summary gets all azure aks kubernetes runtime instances.
// @Description Get all azure aks kubernetes runtime instances from the Threeport database.
// @ID get-v0-azureAksKubernetesRuntimeInstances
// @Accept json
// @Produce json
// @Param name query string false "azure aks kubernetes runtime instance search by name"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/azure-aks-kubernetes-runtime-instances [GET]
func (h Handler) GetAzureAksKubernetesRuntimeInstances(c echo.Context) error {
	objectType := api_v0.ObjectTypeAzureAksKubernetesRuntimeInstance
	params, err := c.(*apiserver_lib.CustomContext).GetPaginationParams()
	if err != nil {
		return apiserver_lib.ResponseStatus400(c, &params, err, objectType)
	}

	var filter api_v0.AzureAksKubernetesRuntimeInstance
	if err := c.Bind(&filter); err != nil {
		return apiserver_lib.ResponseStatus500(c, &params, err, objectType)
	}

	var totalCount int64
	if result := h.DB.Model(&api_v0.AzureAksKubernetesRuntimeInstance{}).Where(&filter).Count(&totalCount); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, &params, result.Error, objectType)
	}

	records := &[]api_v0.AzureAksKubernetesRuntimeInstance{}
	if result := h.DB.Order("ID asc").Where(&filter).Limit(params.Size).Offset((params.Page - 1) * params.Size).Find(records); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, &params, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(apiserver_lib.CreateMeta(params, totalCount), *records, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, &params, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary gets a azure aks kubernetes runtime instance.
// @Description Get a particular azure aks kubernetes runtime instance from the database.
// @ID get-v0-azureAksKubernetesRuntimeInstance
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/azure-aks-kubernetes-runtime-instances/{id} [GET]
func (h Handler) GetAzureAksKubernetesRuntimeInstance(c echo.Context) error {
	objectType := api_v0.ObjectTypeAzureAksKubernetesRuntimeInstance
	azureAksKubernetesRuntimeInstanceID := c.Param("id")
	var azureAksKubernetesRuntimeInstance api_v0.AzureAksKubernetesRuntimeInstance
	if result := h.DB.First(&azureAksKubernetesRuntimeInstance, azureAksKubernetesRuntimeInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, azureAksKubernetesRuntimeInstance, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary updates specific fields for an existing azure aks kubernetes runtime instance.
// @Description Update a azure aks kubernetes runtime instance in the database.  Provide one or more fields to update.
// @Description Note: This API endpint is for updating azure aks kubernetes runtime instance objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID update-v0-azureAksKubernetesRuntimeInstance
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param azureAksKubernetesRuntimeInstance body api_v0.AzureAksKubernetesRuntimeInstance true "AzureAksKubernetesRuntimeInstance object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/azure-aks-kubernetes-runtime-instances/{id} [PATCH]
func (h Handler) UpdateAzureAksKubernetesRuntimeInstance(c echo.Context) error {
	objectType := api_v0.ObjectTypeAzureAksKubernetesRuntimeInstance
	azureAksKubernetesRuntimeInstanceID := c.Param("id")
	var existingAzureAksKubernetesRuntimeInstance api_v0.AzureAksKubernetesRuntimeInstance
	if result := h.DB.First(&existingAzureAksKubernetesRuntimeInstance, azureAksKubernetesRuntimeInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, true, objectType, existingAzureAksKubernetesRuntimeInstance); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedAzureAksKubernetesRuntimeInstance api_v0.AzureAksKubernetesRuntimeInstance
	if err := c.Bind(&updatedAzureAksKubernetesRuntimeInstance); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// update object in database
	if result := h.DB.Model(&existingAzureAksKubernetesRuntimeInstance).Updates(updatedAzureAksKubernetesRuntimeInstance); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// notify controller if reconciliation is required
	if !*existingAzureAksKubernetesRuntimeInstance.Reconciled {
		notifPayload, err := existingAzureAksKubernetesRuntimeInstance.NotificationPayload(
			notifications.NotificationOperationUpdated,
			false,
			time.Now().Unix(),
		)
		if err != nil {
			return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
		}
		h.JS.Publish(notif.AzureAksKubernetesRuntimeInstanceUpdateSubject, *notifPayload)
	}

	response, err := apiserver_lib.CreateResponse(nil, existingAzureAksKubernetesRuntimeInstance, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary updates an existing azure aks kubernetes runtime instance by replacing the entire object.
// @Description Replace a azure aks kubernetes runtime instance in the database.  All required fields must be provided.
// @Description If any optional fields are not provided, they will be null post-update.
// @Description Note: This API endpint is for updating azure aks kubernetes runtime instance objects only.
// @Description Request bodies that include related objects will be accepted, however
// @Description the related objects will not be changed.  Call the patch or put method for
// @Description each particular existing object to change them.
// @ID replace-v0-azureAksKubernetesRuntimeInstance
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Param azureAksKubernetesRuntimeInstance body api_v0.AzureAksKubernetesRuntimeInstance true "AzureAksKubernetesRuntimeInstance object"
// @Success 200 {object} v0.Response "OK"
// @Failure 400 {object} v0.Response "Bad Request"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/azure-aks-kubernetes-runtime-instances/{id} [PUT]
func (h Handler) ReplaceAzureAksKubernetesRuntimeInstance(c echo.Context) error {
	objectType := api_v0.ObjectTypeAzureAksKubernetesRuntimeInstance
	azureAksKubernetesRuntimeInstanceID := c.Param("id")
	var existingAzureAksKubernetesRuntimeInstance api_v0.AzureAksKubernetesRuntimeInstance
	if result := h.DB.First(&existingAzureAksKubernetesRuntimeInstance, azureAksKubernetesRuntimeInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// check for empty payload, invalid or unsupported fields, optional associations, etc.
	if id, err := apiserver_lib.PayloadCheck(c, true, objectType, existingAzureAksKubernetesRuntimeInstance); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// bind payload
	var updatedAzureAksKubernetesRuntimeInstance api_v0.AzureAksKubernetesRuntimeInstance
	if err := c.Bind(&updatedAzureAksKubernetesRuntimeInstance); err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	// check for missing required fields
	if id, err := apiserver_lib.ValidateBoundData(c, updatedAzureAksKubernetesRuntimeInstance, objectType); err != nil {
		return apiserver_lib.ResponseStatusErr(id, c, nil, errors.New(err.Error()), objectType)
	}

	// persist provided data
	updatedAzureAksKubernetesRuntimeInstance.ID = existingAzureAksKubernetesRuntimeInstance.ID
	if result := h.DB.Session(&gorm.Session{FullSaveAssociations: false}).Omit("CreatedAt", "DeletedAt").Save(&updatedAzureAksKubernetesRuntimeInstance); result.Error != nil {
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// reload updated data from DB
	if result := h.DB.First(&existingAzureAksKubernetesRuntimeInstance, azureAksKubernetesRuntimeInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	response, err := apiserver_lib.CreateResponse(nil, existingAzureAksKubernetesRuntimeInstance, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}

// @Summary deletes a azure aks kubernetes runtime instance.
// @Description Delete a azure aks kubernetes runtime instance by ID from the database.
// @ID delete-v0-azureAksKubernetesRuntimeInstance
// @Accept json
// @Produce json
// @Param id path int true "ID"
// @Success 200 {object} v0.Response "OK"
// @Failure 404 {object} v0.Response "Not Found"
// @Failure 409 {object} v0.Response "Conflict"
// @Failure 500 {object} v0.Response "Internal Server Error"
// @Router /v0/azure-aks-kubernetes-runtime-instances/{id} [DELETE]
func (h Handler) DeleteAzureAksKubernetesRuntimeInstance(c echo.Context) error {
	objectType := api_v0.ObjectTypeAzureAksKubernetesRuntimeInstance
	azureAksKubernetesRuntimeInstanceID := c.Param("id")
	var azureAksKubernetesRuntimeInstance api_v0.AzureAksKubernetesRuntimeInstance
	if result := h.DB.First(&azureAksKubernetesRuntimeInstance, azureAksKubernetesRuntimeInstanceID); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return apiserver_lib.ResponseStatus404(c, nil, result.Error, objectType)
		}
		return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
	}

	// schedule for deletion if not already scheduled
	// if scheduled and reconciled, delete object from DB
	// if scheduled but not reconciled, return 409 (controller is working on it)
	if azureAksKubernetesRuntimeInstance.DeletionScheduled == nil {
		// schedule for deletion
		reconciled := false
		timestamp := time.Now().UTC()
		scheduledAzureAksKubernetesRuntimeInstance := api_v0.AzureAksKubernetesRuntimeInstance{
			Reconciliation: api_v0.Reconciliation{
				DeletionScheduled: &timestamp,
				Reconciled:        &reconciled,
			}}
		if result := h.DB.Model(&azureAksKubernetesRuntimeInstance).Updates(scheduledAzureAksKubernetesRuntimeInstance); result.Error != nil {
			return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
		}
		// notify controller
		notifPayload, err := azureAksKubernetesRuntimeInstance.NotificationPayload(
			notifications.NotificationOperationDeleted,
			false,
			time.Now().Unix(),
		)
		if err != nil {
			return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
		}
		h.JS.Publish(notif.AzureAksKubernetesRuntimeInstanceDeleteSubject, *notifPayload)
	} else {
		if azureAksKubernetesRuntimeInstance.DeletionConfirmed == nil {
			// if deletion scheduled but not reconciled, return 409 - deletion
			// already underway
			return apiserver_lib.ResponseStatus409(c, nil, errors.New(fmt.Sprintf(
				"object with ID %d already being deleted",
				*azureAksKubernetesRuntimeInstance.ID,
			)), objectType)
		} else {
			// object scheduled for deletion and confirmed - it can be deleted
			// from DB
			if result := h.DB.Delete(&azureAksKubernetesRuntimeInstance); result.Error != nil {
				return apiserver_lib.ResponseStatus500(c, nil, result.Error, objectType)
			}
		}
	}

	response, err := apiserver_lib.CreateResponse(nil, azureAksKubernetesRuntimeInstance, objectType)
	if err != nil {
		return apiserver_lib.ResponseStatus500(c, nil, err, objectType)
	}

	return apiserver_lib.ResponseStatus200(c, *response)
}
